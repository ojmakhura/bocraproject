// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by SpringWSImpl.java.vsl in andromda-webservices.
//
package bw.org.bocra.portal.report;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.util.Units;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.apache.poi.xwpf.usermodel.XWPFTable;
import org.apache.poi.xwpf.usermodel.XWPFTableRow;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/report")
@CrossOrigin()
public class ReportRestControllerImpl extends ReportRestControllerBase {

    public ReportRestControllerImpl() {

        super();
    }

    @PostMapping(path = "/create/word", consumes = {
            MediaType.APPLICATION_OCTET_STREAM_VALUE,
            MediaType.MULTIPART_FORM_DATA_VALUE
    })
    public ResponseEntity<?> handleCreateWordDocument(@RequestPart("images") MultipartFile[] files,
            @RequestParam("data") String data) throws JsonMappingException, JsonProcessingException {

        ObjectMapper mapper = new ObjectMapper();
        HashMap<String, ?> content = mapper.readValue(data, HashMap.class);
        try {
            XWPFDocument document = new XWPFDocument();

            String formName = content.get("formName").toString();

            XWPFParagraph title = document.createParagraph();
            XWPFRun titleRun = title.createRun();
            titleRun.setText(formName);
            titleRun.setFontSize(24);
            titleRun.setBold(true);
            titleRun.setFontFamily("Calibri");

            ArrayList<HashMap> reportElements = (ArrayList<HashMap>) content.get("reportElements");

            for (HashMap element : reportElements) {
                ArrayList<HashMap> charts = (ArrayList<HashMap>) element.get("charts");

                for (HashMap chart : charts) {

                    Integer index = (Integer) chart.get("imageIndex");

                    if (index != null) {

                        InputStream stream = files[index.intValue()].getInputStream();
                        byte[] buffer = new byte[stream.available()];
                        stream.read(buffer);

                        File targetFile = new File("src/main/resources/targetFile" + index + ".png");
                        try (OutputStream outStream = new FileOutputStream(targetFile)) {
                            outStream.write(buffer);
                        }
                    }
                }
            }

            // System.out.println(reportElements);
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            document.write(out);
            byte[] outArray = out.toByteArray();
            out.flush();
            out.close();
            document.close();

            return ResponseEntity.status(HttpStatus.OK)
                    .contentType(MediaType
                            .parseMediaType("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + formName + ".docx\"")
                    .body(new ByteArrayResource(outArray));
        } catch (Exception e) {
            e.printStackTrace();
            logger.error(e.getMessage());
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping(path = "/complaint/word")
    public ResponseEntity<?> generateComplaintWordReport(@RequestBody(required = true) Map data)
            throws JsonMappingException, JsonProcessingException {

        try {
            XWPFDocument document = new XWPFDocument();
            String reportName = data.get("reportName").toString();

            XWPFParagraph title = document.createParagraph();
            XWPFRun titleRun = title.createRun();
            titleRun.setText(reportName);
            titleRun.setFontSize(22);
            titleRun.setBold(true);
            titleRun.setFontFamily("Calibri");
            titleRun.addBreak();

            ArrayList<HashMap> images = (ArrayList<HashMap>) data.get("images");
            HashMap rep = new HashMap<>();
            rep.put("charts", images);
            this.addImagesAndTables(document, List.of(rep));

            return this.getResponse(document, reportName);

        } catch (Exception e) {
            e.printStackTrace();
            logger.error(e.getMessage());
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    private ResponseEntity<?> getResponse(XWPFDocument document, String documentName) throws IOException {

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        document.write(out);
        out.close();
        document.close();

        return ResponseEntity.status(HttpStatus.OK)
                .contentType(MediaType
                        .parseMediaType("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + documentName + ".docx\"")
                .body(new ByteArrayResource(out.toByteArray()));

    }

    private void addImagesAndTables(XWPFDocument document, List<HashMap> imageInformation)
            throws IllegalArgumentException, IOException, InvalidFormatException {

        for (HashMap element : imageInformation) {
            
            ArrayList<HashMap> charts = (ArrayList<HashMap>) element.get("charts");

            for (HashMap<String, ?> chart : charts) {

                String chartLabel = (String) chart.get("label");
                if (StringUtils.isNotEmpty(chartLabel)) {

                    XWPFParagraph label = document.createParagraph();
                    XWPFRun labelRun = label.createRun();
                    labelRun.setText(chartLabel);
                    labelRun.setFontSize(18);
                    labelRun.setBold(true);
                    labelRun.addBreak();
                }

                String chartType = (String) chart.get("type");

                if (chartType.equals("table")) {

                    Map<String, List<?>> tableData = (Map<String, List<?>>) chart.get("tableData");

                    XWPFTable table = document.createTable();
                    List<String> labels = (List<String>) tableData.get("labels");
                    XWPFTableRow labelRow = table.getRow(0);
                    labelRow.getCell(0).setText("");
                    for (int i = 1; i < labels.size(); i++) {
                        labelRow.addNewTableCell().setText(labels.get(i));
                    }

                    List<List<String>> tableValues = (List<List<String>>) tableData.get("data");
                    for (List<String> values : tableValues) {

                        XWPFTableRow tableRow = table.createRow();
                        for (int i = 0; i < values.size(); i++) {
                            tableRow.getCell(i).setText(values.get(i));
                        }
                    }

                } else if (chartType.equals("pie")) {

                    Map<String, List<Map<String, String>>> images = (Map<String, List<Map<String, String>>>) chart.get("images");

                    images.entrySet().forEach(entry -> {
    
                        XWPFParagraph label = document.createParagraph();
                        XWPFRun labelRun = label.createRun();
                        labelRun.setText(entry.getKey());
                        labelRun.setFontSize(18);
                        labelRun.setBold(true);
                        labelRun.addBreak();

                        List<Map<String, String>> pies = entry.getValue();
                        
                        pies.forEach(pieData -> {

                            String labelString = pieData.get("dataLabel");
    
                            XWPFParagraph pieLabel = document.createParagraph();
                            XWPFRun pieLabelRun = pieLabel.createRun();
                            pieLabelRun.setText(labelString);
                            pieLabelRun.setFontSize(15);

                            String image64 = (String) pieData.get("image");
                            try {
                                this.addImageToDocment(image64, document);
                            } catch (InvalidFormatException e) {
                                
                                e.printStackTrace();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
    
                            String pieChartCaptionText = (String) pieData.get("pieChartCaption");

                            if (StringUtils.isNotEmpty(pieChartCaptionText)) {

                                XWPFParagraph pieChartCaption = document.createParagraph();
                                XWPFRun pieChartCaptionRun = pieChartCaption.createRun();
                                pieChartCaptionRun.setText(pieChartCaptionText);
                                pieChartCaptionRun.addBreak();
                            }
                        });
                    });

                } else {

                    String image64 = (String) chart.get("image");
                    this.addImageToDocment(image64, document);

                }
                String caption = (String) chart.get("caption");
                if (StringUtils.isNotEmpty(caption)) {

                    XWPFParagraph captionParagraph = document.createParagraph();
                    XWPFRun run = captionParagraph.createRun();
                    run.setText(caption);
                    run.addBreak();
                }
            }
        }
    }

    private void addImageToDocment(String image64, XWPFDocument document) throws IOException, InvalidFormatException {

        if (StringUtils.isNotEmpty(image64)) {
            image64 = image64.split(";base64,")[1];
            image64 = image64.split("=")[0];

            byte[] imageData = Base64.getDecoder().decode(image64);
            InputStream in2 = new ByteArrayInputStream(imageData);
            XWPFParagraph image = document.createParagraph();
            XWPFRun imageRun = image.createRun();

            BufferedImage img = ImageIO.read(new ByteArrayInputStream(imageData));

            int w = img.getWidth();
            int h = img.getTileHeight();

            if (w > 450) {
                double scale = 450.0 / w;

                w = (int) (img.getWidth() * scale);
                h = (int) (img.getHeight() * scale);
            }

            imageRun.addPicture(in2, XWPFDocument.PICTURE_TYPE_PNG, "chart",
                    Units.toEMU(w), Units.toEMU(h));

            in2.close();

            imageRun.addBreak();
        }
    }

    @Override
    public ResponseEntity<?> handleCreateWordDocument(Map data) {
        try {
            XWPFDocument document = new XWPFDocument();
            String formName = data.get("formName").toString();

            XWPFParagraph title = document.createParagraph();
            XWPFRun titleRun = title.createRun();
            titleRun.setText(formName);
            titleRun.setFontSize(25);
            titleRun.setBold(true);
            titleRun.setFontFamily("Calibri");
            // titleRun.setColor("fff000");
            titleRun.addBreak();

            ArrayList<HashMap> reportElements = (ArrayList<HashMap>) data.get("reportElements");
            this.addImagesAndTables(document, reportElements);

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            document.write(out);
            out.close();
            document.close();

            return ResponseEntity.status(HttpStatus.OK)
                    .contentType(MediaType
                            .parseMediaType("application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + formName + ".docx\"")
                    .body(new ByteArrayResource(out.toByteArray()));
        } catch (Exception e) {
            e.printStackTrace();
            logger.error(e.getMessage());
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}