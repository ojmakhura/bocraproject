// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by SpringWSImpl.java.vsl in andromda-webservices.
//
package bw.org.bocra.portal.user;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.ws.rs.core.Response;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.keycloak.adapters.RefreshableKeycloakSecurityContext;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.RoleResource;
import org.keycloak.admin.client.resource.RolesResource;
import org.keycloak.admin.client.resource.UserResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.ClientRepresentation;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.RoleRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import bw.org.bocra.portal.licensee.LicenseeService;
import bw.org.bocra.portal.licensee.LicenseeVO;

@RestController
@RequestMapping("user")
@CrossOrigin()
public class UserRestControllerImpl extends UserRestControllerBase {

    @Autowired
    private RestTemplate restTemplate;

    @Value("${keycloak.realm}")
    private String realm;

    @Value("${keycloak.auth-server-url}")
    private String authServerUrl;

    @Value("${keycloak.resource}")
    private String clientId;

    public UserRestControllerImpl(LicenseeUserService licenseeUserService, LicenseeService licenseeService) {
        super(licenseeUserService, licenseeService);
    }

    private Keycloak getKeycloak() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();
        Keycloak keycloak = Keycloak.getInstance(
                context.getDeployment().getAuthServerBaseUrl(), realm,
                getAuthClient(), context.getTokenString());

        return keycloak;
    }

    private RealmResource getRealmResource() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();

        return getKeycloak().realm(context.getRealm());
    }

    private CredentialRepresentation createCredential(String type, String value, Boolean temporary) {
        CredentialRepresentation cred = new CredentialRepresentation();

        cred.setType(type);
        cred.setValue(value);
        cred.setTemporary(temporary);

        return cred;
    }

    private RefreshableKeycloakSecurityContext getSecurityContext() {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return (RefreshableKeycloakSecurityContext) authentication.getCredentials();
    }

    private String getAuthClient() {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();

        // System.out.println(context.getToken().getId());

        return context.getToken().issuedFor;
    }

    private UsersResource getUsersResource() {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();

        Keycloak keycloak = getKeycloak();

        return keycloak.realm(context.getRealm()).users();
    }

    private RolesResource getRolesResource() {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();

        Keycloak keycloak = getKeycloak();

        return keycloak.realm(context.getRealm()).roles();
    }

    private UserRepresentation userVOUserRepresentation(UserVO user) {

        UserRepresentation userRepresentation = new UserRepresentation();

        userRepresentation.setUsername(user.getUsername());
        userRepresentation.setEmail(user.getEmail());
        userRepresentation.setFirstName(user.getFirstName());
        userRepresentation.setLastName(user.getLastName());
        userRepresentation.setEnabled(user.getEnabled());
        userRepresentation.setEmailVerified(false);
        userRepresentation.setRequiredActions(Collections.singletonList("VERIFY_EMAIL"));
        userRepresentation.setCredentials(Collections
                .singletonList(createCredential(CredentialRepresentation.PASSWORD, user.getPassword(), true)));

        if (user.getLicensee() != null && user.getLicensee().getId() != null) {
            Map<String, List<String>> attributes = new HashMap<>();
            List<String> licenseeAttributes = new ArrayList<>();
            licenseeAttributes.add(user.getLicensee().getId().toString());
            licenseeAttributes.add(user.getLicensee().getLicenseeName());
            attributes.put("licensee", licenseeAttributes);

            userRepresentation.setAttributes(attributes);
        }

        if (CollectionUtils.isNotEmpty(user.getRoles())) {
            userRepresentation.getClientRoles();
            Map<String, List<String>> roles = new HashMap<>();
            roles.put(this.getAuthClient(), (List<String>) user.getRoles());
            userRepresentation.setClientRoles(roles);
        }

        return userRepresentation;
    }

    private UserVO userRepresentationUserVO(UserRepresentation userRepresentation) {
        UserVO user = new UserVO();

        user.setUserId(userRepresentation.getId());
        user.setEmail(userRepresentation.getEmail());
        user.setEnabled(userRepresentation.isEnabled());
        user.setFirstName(userRepresentation.getFirstName());
        user.setUsername(userRepresentation.getUsername());
        user.setRoles(new ArrayList<>());
        System.out.println(userRepresentation.getClientRoles());

        if (userRepresentation.getAttributes() != null && !userRepresentation.getAttributes().isEmpty()) {
            List<String> licenseeAttributes = userRepresentation.getAttributes().get("licensee");

            if (CollectionUtils.isNotEmpty(licenseeAttributes)) {
                LicenseeVO licensee = licenseeService.findById(Long.parseLong(licenseeAttributes.get(0)));
                System.out.println(licensee);
            }
        }

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        RefreshableKeycloakSecurityContext context = (RefreshableKeycloakSecurityContext) authentication
                .getCredentials();

        RealmResource realmResource = getRealmResource();
        UserResource userResource = realmResource.users().get(userRepresentation.getId());

        System.out.println(getAuthClient());

        ClientRepresentation clientRepresentation = getRealmResource().clients().findByClientId(getAuthClient()).get(0);
        System.out.println(userResource.roles().getAll().getClientMappings());
        System.out.println(userResource.roles().getAll().getRealmMappings());
        System.out.println(userResource.roles().clientLevel(clientRepresentation.getId()).listAll());

        for (RoleRepresentation roleRep : userResource.roles().clientLevel(clientRepresentation.getId()).listAll()) {
            System.out.println(roleRep.getContainerId());
            System.out.println(roleRep.getAttributes());
            System.out.println(roleRep.getDescription());
            user.getRoles().add(roleRep.getName());
        }

        return user;
    }

    @GetMapping("/test")
    public String testUser() {

        System.out.println(getSecurityContext().getDeployment().getAuthServerBaseUrl());
        System.out.println(getSecurityContext().getDeployment().getAccountUrl());
        System.out.println(getSecurityContext().getDeployment().getLogoutUrl());
        System.out.println(getSecurityContext().getRealm());
        System.out.println(getAuthClient());
        System.out.println(getSecurityContext().getToken().issuedFor);
        System.out.println(getSecurityContext().getToken().getId());
        System.out.println(getSecurityContext().getToken().getIssuedFor());
        System.out.println(getSecurityContext().getToken().getSubject());
        String userId = getSecurityContext().getToken().getSubject();
        UserRepresentation currentUser = getRealmResource().users().get(userId)
                .toRepresentation();

        System.out.println(currentUser.getClientConsents());
        System.out.println(currentUser.getRealmRoles());
        System.out.println(currentUser.getClientRoles());
        Keycloak keycloak = KeycloakBuilder.builder()
                .authorization(getSecurityContext().getTokenString())
                .serverUrl(getSecurityContext().getDeployment().getAuthServerBaseUrl())
                .realm(getSecurityContext().getRealm())
                .build();

        RealmResource realmResource = keycloak.realm(realm);
        UsersResource usersRessource = realmResource.users();

        UserResource userResource = usersRessource.get(getSecurityContext().getToken().getSubject());

        System.out.println(userResource.toRepresentation().getFirstName());
        // userResource.roles().clientLevel(getSecurityContext().getToken().issuedFor).listAll();
        System.out.println(realmResource.clients().get(getSecurityContext().getToken().issuedFor).roles().list());
        System.out.println(realmResource.clients().get(getSecurityContext().getToken().issuedFor).toRepresentation()
                .getClientId());

        List<RoleRepresentation> reps = userResource.roles().clientLevel(getSecurityContext().getToken().issuedFor)
                .listAvailable();

        System.out.println(reps);

        System.out.println(keycloak.realms().realm(getSecurityContext().getRealm()).toRepresentation().getRoles());
        // getRealmResource().users().get(userId).roles().clientLevel(getAuthClient()).listAll();

        // System.out.println(userRepresentation.getClientRoles());
        // RoleResource rs =
        // getRealmResource().roles().get(user.getRoles().iterator().next());
        // System.out.println(rs);
        // System.out.println(rs.getRoleComposites());

        return "test";
    }

    @Override
    public ResponseEntity<?> handleCreateUser(UserVO user) {

        // UsersResource usersResource = getUsersResource();
        // UserRepresentation userRepresentation = this.userVOUserRepresentation(user);

        // String url = getSecurityContext().getDeployment().getAuthServerBaseUrl() + "/admin/realms/"
        //         + getSecurityContext().getRealm() + "/users";

        // System.out.println(userRepresentation);
        // ResponseEntity<Response> res = restTemplate.postForEntity(url, userRepresentation, Response.class);

        // Response r = res.getBody();
        // System.out.println(r.getEntity());
        
        // restTemplate.postForEntity(url, request, responseType, uriVariables)

        // Response res = usersResource.create(userRepresentation);
        // System.out.println(res.getEntity());

        // List<UserRepresentation> users = usersResource.search(user.getUsername(), true);
        // if (CollectionUtils.isNotEmpty(users)) {

        //     UserRepresentation rep = users.get(0);

        //     if (StringUtils.isNotBlank(rep.getId())) {
        //         user.setUserId(rep.getId());
        //         LicenseeUserVO licenseeUser = new LicenseeUserVO();
        //         licenseeUser.setDateAdded(LocalDate.now());
        //         licenseeUser.setUser(user);
        //         licenseeUser.setLicensee(user.getLicensee());
        //         // licenseeUser = licenseeUserService.save(licenseeUser);
        //     }
        // } else {
        //     return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        // }

        return ResponseEntity.status(HttpStatus.OK).body(user);
    }

    @Override
    public ResponseEntity<?> handleLoadUsers() {

        UsersResource usersResource = getUsersResource();

        List<UserRepresentation> userRep = usersResource.list();
        System.out.println("==================================");
        Collection<UserVO> users = new ArrayList<>();

        for (UserRepresentation user : userRep) {
            UserVO vo = this.userRepresentationUserVO(user);
            users.add(vo);
        }

        Optional<Collection<UserVO>> data = CollectionUtils.isEmpty(users) ? Optional.empty() : Optional.of(users);
        ResponseEntity<Collection<UserVO>> response;

        if (data.isPresent()) {
            response = ResponseEntity.status(HttpStatus.OK).body(data.get());
        } else {
            response = ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }

        return response;
    }

    @Override
    public ResponseEntity<?> handleUpdateUserName(String username, String userId) {
        Optional<Boolean> data = Optional.empty(); // TODO: Add custom code here;
        ResponseEntity<Boolean> response;

        if (data.isPresent()) {
            response = ResponseEntity.status(HttpStatus.OK).body(data.get());
        } else {
            response = ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }

        return response;
    }

    @Override
    public ResponseEntity<?> handleSearch(String criteria) {

        List<UserRepresentation> usersRep = getUsersResource().search(criteria, false);

        if (CollectionUtils.isEmpty(usersRep)) {
            return ResponseEntity.noContent().build();
        }

        List<UserVO> users = new ArrayList<>();

        for (UserRepresentation rep : usersRep) {
            users.add(userRepresentationUserVO(rep));
        }

        return ResponseEntity.ok(users);
    }
}