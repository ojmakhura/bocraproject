// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { HttpClient } from '@angular/common/http';
import { Component, Injector } from '@angular/core';
import { EditAuthorisationSaveForm, EditAuthorisationVarsForm } from '@app/view/auth/edit-authorisation.component';
import { EditAuthorisationComponent, EditAuthorisationDeleteForm } from '@app/view/auth/edit-authorisation.component';
import { SelectItem } from '@app/utils/select-item';
import { environment } from '@env/environment';
import * as AuthorisationActions from '@app/store/auth/authorisation.actions';
import * as AccessPointSelectors from '@app/store/access/access-point.selectors';
import * as AccessPointActions from '@app/store/access/access-point.actions';

import { KeycloakService } from 'keycloak-angular';
import { select } from '@ngrx/store';
import { AccessPointCriteria } from '@app/model/bw/org/bocra/portal/access/access-point-criteria';
import { FormGroup } from '@angular/forms';
import { AccessPointVO } from '@app/model/bw/org/bocra/portal/access/access-point-vo';
import * as ViewActions from '@app/store/view/view.actions';
import * as ViewSelectors from '@app/store/view/view.selectors';
import { Observable } from 'rxjs';
@Component({
  selector: 'app-edit-authorisation',
  templateUrl: './edit-authorisation.component.html',
  styleUrls: ['./edit-authorisation.component.scss'],
})
export class EditAuthorisationComponentImpl extends EditAuthorisationComponent {

  protected http: HttpClient;
  protected keycloakService: KeycloakService;
  unauthorisedUrls$: Observable<string[]>;
  deleteUnrestricted: boolean = true;

  constructor(private injector: Injector) {
    super(injector);
    this.http = this._injector.get(HttpClient);
    this.keycloakService = this._injector.get(KeycloakService);
    this.authorisationAccessPoints$ = this.store.pipe(select(AccessPointSelectors.selectAccessPoints));
    this.unauthorisedUrls$ = this.store.pipe(select(ViewSelectors.selectUnauthorisedUrls));
  }

  override doNgOnDestroy(): void {
  }

  beforeOnInit(form: EditAuthorisationVarsForm): EditAuthorisationVarsForm {
    this.http.get<any[]>(environment.keycloakClientRoleUrl).subscribe((roles) => {

      roles.sort((a, b) => a.name.localeCompare(b.name)).forEach((role) => {
        if (this.keycloakService.getUserRoles().includes(role.name)) {

          let item = new SelectItem();
          item.label = role['description'];
          item.value = role['name'];

          this.authorisationRolesBackingList.push(item);
        }
      });
    });

    return form;
  }

  override handleFormChanges(change: any): void {
  }

  override afterOnInit() {

  }

  override createAccessPointVOGroup(value: AccessPointVO): FormGroup {
    return this.formBuilder.group({
      id: [value?.id],
      createdBy: [value?.createdBy],
      updatedBy: [value?.updatedBy],
      createdDate: [value?.createdDate],
      updatedDate: [value?.updatedDate],
      name: [value?.name],
      url: [value?.url],
      accessPointType: this.formBuilder.group({
        id: [value?.accessPointType?.id],
        code: [value?.accessPointType?.code],
        name: [value?.accessPointType?.name]
      })
    });
  }

  override doNgAfterViewInit(): void {
    this.store.dispatch(
      ViewActions.loadViewAuthorisations({
        viewUrl: "/auth/edit-authorisation",
        roles: this.keycloakService.getUserRoles(),
        loading: true
      })
    );

    this.route.queryParams.subscribe((queryParams: any) => {
      if (queryParams?.id) {
        this.store.dispatch(
          AuthorisationActions.findById({
            id: queryParams?.id,
            loading: false,
          })
        );
      }
    });

    this.store.dispatch(
      ViewActions.loadViewAuthorisations({
        viewUrl: "/authorisation/edit-authorisation",
        roles: this.keycloakService.getUserRoles(),
        loading: true
      })
    );

    this.unauthorisedUrls$.subscribe(restrictedItems => {
      restrictedItems.forEach(item => {
        if (item === '/authorisation/edit-authorisation/{button:delete}') {
          this.deleteUnrestricted = false;
        }
      });
    });

    this.authorisation$.subscribe((authorisation) => {
      this.setEditAuthorisationFormValue({ authorisation: authorisation });
    });

    this.unauthorisedUrls$.subscribe(restrictedItems => {
      restrictedItems.forEach(item => {
        if (item === '/auth/edit-authorisation/{button:delete}') {
          this.deleteUnrestricted = false;
        }
      });
    });
  }

  /**
   * This method may be overwritten
   */
  override beforeEditAuthorisationSave(form: EditAuthorisationSaveForm): void {
    if (this.editAuthorisationForm.valid && this.editAuthorisationForm.pristine) {
      if (form.authorisation?.id) {
        form.authorisation.updatedBy = this.keycloakService.getUsername();
        form.authorisation.updatedDate = new Date();
      } else {
        form.authorisation.createdBy = this.keycloakService.getUsername();
        form.authorisation.createdDate = new Date();
      }
      this.store.dispatch(
        AuthorisationActions.save({
          authorisation: form.authorisation,
          loading: true,
        })
      );

    } else {

      this.store.dispatch(AuthorisationActions.authorisationFailure({ messages: ['Form has to be filled'] }));
    }
  }

  override beforeEditAuthorisationDelete(form: EditAuthorisationDeleteForm): void {
    if (form?.authorisation?.id && confirm("Are you sure you want to delete the authorisation?")) {
      this.store.dispatch(
        AuthorisationActions.remove({
          id: form?.authorisation?.id,
          loading: false,
        })
      );
      this.editAuthorisationFormReset();
    } else {

      this.store.dispatch(AuthorisationActions.authorisationFailure({ messages: ['Please select something to delete'] }));
    }
  }

  override authorisationAccessPointSearch(): void {
    let criteria: AccessPointCriteria = new AccessPointCriteria();
    criteria.name = this.authorisationAccessPointSearchField.value;
    criteria.url = this.authorisationAccessPointSearchField.value;
    this.store.dispatch(AccessPointActions.search({ criteria: criteria, loading: true }));
  }
}
