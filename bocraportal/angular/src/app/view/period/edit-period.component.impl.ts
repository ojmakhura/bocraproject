// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { formatDate } from '@angular/common';
import { Component, Injector } from '@angular/core';
import { PeriodConfigVO } from '@app/model/bw/org/bocra/portal/period/config/period-config-vo';
import { RepeatPeriod } from '@app/model/bw/org/bocra/portal/period/config/repeat-period';
import { PeriodVO } from '@app/model/bw/org/bocra/portal/period/period-vo';
import * as PeriodConfigActions from '@app/store/period/config/period-config.actions';
import * as PeriodConfigSelectors from '@app/store/period/config/period-config.selectors';
import * as PeriodActions from '@app/store/period/period.actions';
import * as PeriodSelectors from '@app/store/period/period.selectors';
import * as ViewActions from '@app/store/view/view.actions';
import * as ViewSelectors from '@app/store/view/view.selectors';
import {
  EditPeriodComponent,
  EditPeriodCreateNextForm,
  EditPeriodDeleteForm,
  EditPeriodSaveForm,
  EditPeriodVarsForm,
} from '@app/view/period/edit-period.component';
import { select } from '@ngrx/store';
import { KeycloakService } from 'keycloak-angular';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-edit-period',
  templateUrl: './edit-period.component.html',
  styleUrls: ['./edit-period.component.scss'],
})
export class EditPeriodComponentImpl extends EditPeriodComponent {
  protected keycloakService: KeycloakService;
  unauthorisedUrls$: Observable<string[]>;
  deleteUnrestricted: boolean = true;
  periodConfigPeriodConfigNameControl: any;

  constructor(private injector: Injector) {
    super(injector);
    this.keycloakService = injector.get(KeycloakService);
    this.periodPeriodConfigs$ = this.store.pipe(select(PeriodConfigSelectors.selectPeriodConfigs));
    this.periodNexts$ = this.store.pipe(select(PeriodSelectors.selectPeriods));
    this.periodPreviouses$ = this.store.pipe(select(PeriodSelectors.selectPeriods));
    this.unauthorisedUrls$ = this.store.pipe(select(ViewSelectors.selectUnauthorisedUrls));
  }

  override beforeOnInit(form: EditPeriodVarsForm): EditPeriodVarsForm {
    return form;
  }

  override doNgOnDestroy() {}

  override doNgAfterViewInit() {
    this.store.dispatch(
      ViewActions.loadViewAuthorisations({
        viewUrl: 'period/edit-period',
        roles: this.keycloakService.getUserRoles(),
        loading: true,
      })
    );

    this.route.queryParams.subscribe((queryParams: any) => {
      if (queryParams?.id) {
        this.store.dispatch(
          PeriodActions.findById({
            id: queryParams?.id,
            loading: true,
            loaderMessage: 'Loading period by id ...',
          })
        );
      }
    });

    this.period$.subscribe((period) => {
      this.setEditPeriodFormValue({ period: period });
    });

    this.periodPeriodConfigControl.valueChanges.subscribe((change) => {
      if (change?.id && this.periodPeriodStart) {
        let end = this.calculateEndDate(new Date(this.periodPeriodStart), this.periodPeriodConfig);
        this.periodPeriodEndControl.patchValue(formatDate(end, 'yyyy-MM-dd', 'en-bw'));
        let name = this.getPeriodName(new Date(this.periodPeriodStart), end);
        this.periodPeriodNameControl.patchValue(name);
      }
    });

    this.periodPeriodStartControl.valueChanges.subscribe((start) => {
      if (this.periodPeriodConfig?.periodConfigName) {
        let end = this.calculateEndDate(new Date(this.periodPeriodStart), this.periodPeriodConfig);
        this.periodPeriodEndControl.patchValue(formatDate(end, 'yyyy-MM-dd', 'en-bw'));
        let name = this.getPeriodName(new Date(this.periodPeriodStart), end);
        this.periodPeriodNameControl.patchValue(name);
      }
    });

    this.unauthorisedUrls$.subscribe((restrictedItems) => {
      restrictedItems.forEach((item) => {
        if (item === '/period/edit-period/{button:delete}') {
          this.deleteUnrestricted = false;
        }
      });
    });
  }

  calculateEndDate(start: Date, config: PeriodConfigVO): Date {
    let next: Date = new Date(start.toString());

    if (config.repeatPeriod === RepeatPeriod.MONTHS) {
      next.setMonth(start.getMonth() + config.repeat);
    } else if (config.repeatPeriod === RepeatPeriod.YEARS) {
      next.setFullYear(start.getFullYear() + config.repeat);
      next.setMonth(start.getMonth());
    }
    next.setDate(next.getDate() - 1);

    return next;
  }

  getPeriodName(start: Date, next: Date): string {
    let val: string = `${start.getFullYear()}`;

    if (start.getFullYear() != next.getFullYear()) {
      val = `${start.toLocaleString('en-bw', { month: 'short' })} ${start.getFullYear()} - ${next.toLocaleString(
        'en-bw',
        { month: 'short' }
      )} ${next.toLocaleString('en-bw', { year: 'numeric' })}`;
    } else {
      val = `${start.toLocaleString('en-bw', { month: 'short' })}`;
      if (start.getMonth() != next.getMonth()) {
        val = `${val} - ${next.toLocaleString('en-bw', { month: 'short' })}`;
      }

      val = `${val} ${next.toLocaleString('en-bw', { year: 'numeric' })}`;
    }

    return val;
  }

  /**
   * This method may be overwritten
   */
  override beforeEditPeriodSave(form: EditPeriodSaveForm): void {
    if (this.periodControl.valid) {
      if (form.period.id) {
        form.period.updatedBy = this.keycloakService.getUsername();
        form.period.updatedDate = new Date();
      } else {
        form.period.createdBy = this.keycloakService.getUsername();
        form.period.createdDate = new Date();
      }
      this.store.dispatch(
        PeriodActions.save({
          period: form.period,
          loading: true,
          loaderMessage: 'Saving period ...',
        })
      );
    } else {
      let messages: string[] = [];
      if (!this.periodControl.valid) {
        messages.push('Period has errors, Please fill in the required form fields');
      }
      if (!this.periodPeriodNameControl.valid) {
        messages.push('Period Name missing!');
      }
      // if(!this.periodPeriodConfigControl.valid) {
      //   messages.push("Repeat Period missing!")
      // }
      this.store.dispatch(PeriodActions.periodFailure({ messages: messages }));
    }
  }

  override handleFormChanges(change: any): void {}

  override periodPeriodConfigSearch(): void {
    this.store.dispatch(
      PeriodConfigActions.search({
        criteria: { periodConfigName: this.periodPeriodConfigSearchField.value },
        loading: true,
        loaderMessage: 'Searching period configs ...',
      })
    );
  }

  override periodPreviousSearch() {
    this.store.dispatch(
      PeriodActions.search({
        criteria: { periodName: this.periodPreviousSearchField.value },
        loading: true,
        loaderMessage: 'Searching periods ...',
      })
    );
  }

  override periodNextSearch() {
    this.store.dispatch(
      PeriodActions.search({
        criteria: { periodName: this.periodNextSearchField.value },
        loading: true,
        loaderMessage: 'Searching periods ...',
      })
    );
  }

  override beforeEditPeriodDelete(form: EditPeriodDeleteForm): void {
    if (form?.period?.id) {
      if (!form?.period?.periodConfig?.id && confirm('Are you sure you want to delete the form activation?')) {
        this.store.dispatch(
          PeriodActions.remove({
            id: form.period?.id,
            loading: true,
            loaderMessage: 'Removing form submission ...',
          })
        );
        this.editPeriodFormReset();
      } else {
        this.store.dispatch(
          PeriodActions.periodFailure({
            messages: ['This Period not be deleted, it is attached to a period configuration'],
          })
        );
      }
    } else {
      this.store.dispatch(PeriodActions.periodFailure({ messages: ['Please select something to delete'] }));
    }
  }
  // override beforeEditPeriodDelete(form: EditPeriodDeleteForm): void {
  //   if (form?.period?.id && confirm("Are you sure you want to delete the period?")) {
  //     this.store.dispatch(
  //       PeriodActions.remove({
  //         id: form?.period?.id,
  //         loading: false,
  //         loaderMessage: 'Removing periods ...'
  //       })
  //     );
  //     this.editPeriodFormReset();
  //   } else {
  //     this.store.dispatch(PeriodActions.periodFailure({ messages: ['Please select something to delete'] }));
  //   }
  // }

  override afterEditPeriodCreateNext(form: EditPeriodCreateNextForm): void {
    this.editPeriodFormReset();

    if (form?.period?.id) {
      let current: PeriodVO = form.period;
      let next: PeriodVO = new PeriodVO();

      next.periodConfig = current.periodConfig;

      let start: Date = new Date(current.periodEnd);
      start.setDate(start.getDate() + 1);

      next.periodStart = formatDate(start, 'yyyy-MM-dd', 'en-bw');
      let end: Date = this.calculateEndDate(start, next.periodConfig);

      next.periodEnd = formatDate(end, 'yyyy-MM-dd', 'en-bw');
      next.periodName = this.getPeriodName(start, end);
      next.previous = current;

      this.editPeriodForm = this.newForm({ period: next });
    }
  }

  scroll(el: HTMLElement) {
    el.scrollIntoView();
  }
}
