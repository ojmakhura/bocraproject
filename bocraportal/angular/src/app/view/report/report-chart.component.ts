// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { AfterViewInit, Component, Injector, Input, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { FormSubmissionVO } from '@app/model/bw/org/bocra/portal/form/submission/form-submission-vo';
import { ChartDataset, Chart } from 'chart.js';
import { BaseChartDirective } from 'ng2-charts';
import * as pluginAnnotation from 'chartjs-plugin-annotation';

Chart.register(pluginAnnotation);

export class ReportChart {
  chartLabel: string = '';
  chartType: string = '';
  labels: string[] = [];
  data: number[] = [];
  chartCaption: string = '';
}

@Component({
  selector: 'app-report-chart',
  templateUrl: './report-chart.component.html',
})
export class ReportChartComponent implements OnInit, AfterViewInit, OnDestroy {
  @Input() reportChartGroup: FormGroup | any;
  protected formBuilder: FormBuilder;

  @Input() selectedFields: any[];
  @Input() selectedLicensees: any[];
  @Input() selectedPeriods: any[];

  @Input() reportType: string;
  @Input() dataColumns: string;
  @Input() dataRows: string;
  @Input() colors: any;
  @Input() chartIndex: number;
  @Input() grid: any;
  @Input() gridColumnHeaders: any[];

  sections: any[] = [];
  periods: any[] = [];
  labelNames: string[] = [];
  chartData: any = [];
  chartOptions: any = {};
  chartPlugins: any[] = [];

  @Input() selectedSubmissions: any;

  @ViewChild(BaseChartDirective) chart: BaseChartDirective;

  datasets: ChartDataset[] = [];

  constructor(private injector: Injector) {
    this.formBuilder = this.injector.get(FormBuilder);
  }

  ngOnInit(): void {
    this.reportChartGroup.addControl('period', this.formBuilder.control([]));
    this.reportChartGroup.addControl('section', this.formBuilder.control([]));
    this.reportChartGroup.addControl('chartLabel', this.formBuilder.control([]));
    this.reportChartGroup.addControl('chartCaption', this.formBuilder.control([]));
    this.reportChartGroup.addControl('scaleType', this.formBuilder.control([]));
    this.reportChartGroup.addControl('target', this.formBuilder.control([]));
    this.reportChartGroup.addControl('minimum', this.formBuilder.control([]));
    this.reportChartGroup.addControl('limit', this.formBuilder.control([]));
    this.reportChartGroup.addControl('limitOrder', this.formBuilder.control([]));
    this.chartTypeControl.patchValue('bar');
    this.periodControl.patchValue('all');

    this.datasets = this.basicDatasets();
  }

  ngAfterViewInit(): void {
  }

  ngOnDestroy(): void {}

  getChartControls() {
    let chartControls: FormGroup = this.formBuilder.group({
      scaleType: [''],
    });

    return chartControls;
  }

  scaleTypeChanged() {
    this.chartOptions.scales.y.type = this.scaleTypeControl.value;
    this.chart.render();
  }

  get scaleTypeControl(): FormControl {
    return this.reportChartGroup.get('scaleType') as FormControl;
  }

  get targetControl(): FormControl {
    return this.reportChartGroup.get('target') as FormControl;
  }

  targetChange() {}

  basicDatasets() {
    
    this.labelNames = [];
    this.periods = [];

    let columns = this.dataColumns === 'licensees' ? this.selectedLicensees : this.selectedFields;
    let rows = this.dataColumns === 'licensees' ? this.selectedFields : this.selectedLicensees;

    let colSelector = this.dataColumns === 'licensees' ? 'licensee' : 'alias';
    let rowSelector = this.dataColumns === 'licensees' ? 'alias' : 'licensee';
    let colourSelector = this.dataColumns === 'licensees' ? 'fieldId' : 'licensee';

    let periods =
      this.period === 'all' ? this.selectedPeriods : this.selectedPeriods.filter((p) => this.period === p?.period);

    let tmpSet = {};

    periods?.forEach((pr) => {
      let gridValues = Object.values(this.grid);

      if (!tmpSet[pr.alias]) {
        tmpSet[pr.alias] = {
        };
      }

      rows.forEach((row) => {
        let found: any = gridValues.find((gv: any) => gv?.label === row[rowSelector]);

        if (tmpSet[pr.alias][row[rowSelector]]?.data === undefined) {
          tmpSet[pr.alias][row[rowSelector]] = {
            label: row[rowSelector],
            backgroundColor: this.colors[row[colourSelector]],
            data: [],
          };
        }

        let fvalues = Object.values(found);
        columns?.forEach((col) => {

          let foundData: any = fvalues.find((fv: any) => fv?.period === pr.period && fv?.label === col[colSelector]);
          
          if (foundData && foundData.active) {
            tmpSet[pr.alias][row[rowSelector]]?.data.push(foundData.value);
          } else if(this.dataColumns === 'fields') {

            tmpSet[pr.alias][row[rowSelector]]?.data.push(0);
          }
        });
      });
    });

    let temp = {};

    periods.forEach((pr) => {

      rows.forEach((row) => {
        
        let k = row[rowSelector];

        if (tmpSet[pr.alias][k]) {

          if (this.dataRows === 'licensees') {
            tmpSet[pr.alias][k].backgroundColor = this.colors[row[colourSelector]];
          }

          if (!temp[tmpSet[pr.alias][k].label]) {

            temp[tmpSet[pr.alias][k].label] = {};
            temp[tmpSet[pr.alias][k].label].backgroundColor = this.colors[row[colourSelector]];
            temp[tmpSet[pr.alias][k].label].data = [];
            temp[tmpSet[pr.alias][k].label].label = tmpSet[pr.alias][k].label;
          }

          temp[tmpSet[pr.alias][k].label].data = temp[tmpSet[pr.alias][k].label].data.concat(tmpSet[pr.alias][k].data);
        }
      });
    });

    let dset: any[] = Object.values(temp);
        
    this.periods = this.selectedPeriods?.map((per) => per.alias);

    this.getChartOptions();
    this.getChartPlugins();

    this.labelNames = this.period === 'all' ? 
                      this.gridColumnHeaders
                        .filter(g => this.selectedPeriods.find((p) => p.period === g.period))
                        // .filter(g => this.selectedPeriods.find((p) => p.period === g.period))
                        .map((h) => h.label) : 
                      this.gridColumnHeaders
                        .filter(g => g.period === this.period)
                        .map((h) => h.label);

    if (this.dataRows === 'licensees') {
      this.labelNames = this.labelNames.filter((l) => this.selectedFields.find((f) => f.alias === l));
    } else {
      this.labelNames = this.labelNames.filter((l) => this.selectedLicensees.find((f) => f.licensee === l));
    }

    return dset;
  }

  getChartOptions() {
    
    this.chartOptions = {
      responsive: true,
      layout: {
        padding: {
          bottom: 50,
        },
      },
      scales: {
        y: {
          display: true,
          type: 'linear',
        },
      },
      plugins: {
        plugins: {
          annotation: {
            annotations: {
              l1:{
                type: 'line',
                borderColor: 'black',
                borderWidth: 3,
                scaleID: 'y',
                value: 1500000,
              },
            },
          },
        },
      },
    };
  }

  getChartTargetLine(target: number) {}

  getChartAnnotations() {}

  getChartPlugins() {
    let periods =
      this.period === 'all' ? this.selectedPeriods : this.selectedPeriods.filter((p) => this.period === p?.period);
    let subs = this.selectedSubmissions;
    let names = this.labelNames;

    let cols = this.dataColumns;
    let rows = this.dataRows;
    
    let sFields = this.selectedFields;

    if (this.chart?.plugins) {
      this.chart.plugins = [];
    }

    this.chartPlugins = [
      pluginAnnotation,
      {
        id: 'subLabels',
        afterDatasetsDraw(chart: any, args: any, pluginOptions: any) {
          var pr = document.getElementById('period');
          var val = pr['value'];

          const {
            ctx,
            chartArea: { left, width },
            scales: { 
              x: {
                bottom: bottomAxis, // bottom of the labels
              }
            },
          } = chart;
          ctx.save();

          let stepValue = width / names.length;

          var prs = val === 'all' ? periods : periods.filter((p) => p?.period === val);

          if (prs.length > 1) {
            let start = 0;
            periods.forEach((pr) => {
              let s = rows === 'fields' ? subs[pr.alias] : sFields;
              
              subLabelText(pr.alias, start, bottomAxis);
              start += stepValue * s.length;
            });
          }

          function subLabelText(text: any, x: any, y: any) {
            
            ctx.font = 'bolder 12px sans-serif';
            ctx.fillStyle = 'rgba(102, 102, 102, 1)';
            ctx.textAlign = 'left';
            ctx.fillText(text, x + left, y + 10);
          }
        },
      },
    ];
  }

  getDafieldAsLabels(data: any) {
    let keys = Object.keys(data);
    let selectedFieldNames = this.selectedFields?.map((fl) => fl.alias);
    let labels: string[] = selectedFieldNames;

    if (keys.length > 0) {
      let len = data[keys[0]].data.length;
      let multiplier = len / this.selectedFields.length;

      for (let i = 1; i < multiplier; i++) {
        labels = labels.concat(selectedFieldNames);
      }
    }

    return labels;
  }

  getSelectedSubmissionLicensees() {
    let licensees: string[] = [];

    this.selectedPeriods.forEach((per) => {
      
      if (this.period === 'all' || this.period === per.period) {
        let submissions: any[] = this.selectedSubmissions[per.period];

        submissions.forEach((sub) => {
          licensees.push(sub.licensee);
        });
      }
    });

    return licensees;
  }

  newForm(chart: ReportChart): FormGroup {
    return this.formBuilder.group({
      chartLabel: [chart?.chartLabel],
      chartType: [chart?.chartType],
      chartCaption: [chart?.chartCaption],
      labels: this.formBuilder.array(chart?.labels),
      data: this.formBuilder.array(chart?.data),
      chartImage: [],
    });
  }

  selectedPeriod() {
    
    this.datasets = this.basicDatasets();
    this.getChartPlugins();
  }

  selectedFormSection() {}

  get chartTypeControl() {
    return this.reportChartGroup.get('chartType') as FormControl;
  }

  get chartType() {
    return this.chartTypeControl.value;
  }

  get periodControl() {
    return this.reportChartGroup.get('period') as FormControl;
  }

  get period() {
    return this.periodControl.value;
  }

  get sectionControl() {
    return this.reportChartGroup.get('section') as FormControl;
  }

  get section() {
    return this.sectionControl.value;
  }

  get chartLabelControl() {
    return this.reportChartGroup.get('chartLabel') as FormControl;
  }

  get chartLabel() {
    return this.chartLabelControl.value;
  }

  get chartCaptionControl() {
    return this.reportChartGroup.get('chartCaption') as FormControl;
  }

  get chartCaption() {
    return this.chartCaptionControl.value;
  }

  get chartLimitControl() {
    return this.reportChartGroup.get('limit') as FormControl;
  }

  get limit() {
    return this.chartLimitControl.value;
  }

  get chartLimitOrderControl() {
    return this.reportChartGroup.get('limitOrder') as FormControl;
  }

  get limitOrder() {
    return this.chartLimitOrderControl.value;
  }

  selectedChartType() {
    if (this.chartType === 'bar') {
      this.datasets = this.basicDatasets();
    }
  }

  clearReport() {}

  refreshChart() {
    this.datasets = this.basicDatasets();
  }

  getChartImageData(): any {
    if (this.chartType === 'table') {
      return {
        caption: this.chartCaption,
        label: this.chartLabel,
        type: this.chartType,
        tableData: {
          labels: ['', ...this.labelNames],
          data: this.datasets?.map((d) => [d.label, ...d?.data]),
        },
      };
    } else {
      return {
        caption: this.chartCaption,
        label: this.chartLabel,
        type: this.chartType,
        image: this.chart.toBase64Image(),
      };
    }
  }
}
