// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { AfterViewInit, Component, EventEmitter, Injector, Input, OnDestroy, OnInit, Output, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { FormVO } from '@app/model/bw/org/bocra/portal/form/form-vo';
import { DataFieldSectionVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-section-vo';
import { DataFieldVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-vo';
import { FormSubmissionVO } from '@app/model/bw/org/bocra/portal/form/submission/form-submission-vo';
import * as SubmissionActions from '@app/store/form/submission/form-submission.actions';
import * as SubmissionSelectors from '@app/store/form/submission/form-submission.selectors';
import { ReportComponent } from '@app/view/report/report.component';
import { select } from '@ngrx/store';
import { ChartConfiguration, ChartData, ChartDataset } from 'chart.js';
import { e } from 'mathjs';
import { BaseChartDirective } from 'ng2-charts';
import { Observable, of } from 'rxjs';

export class ReportChart {
  chartLabel: string = '';
  chartType: string = '';
  labels: string[] = [];
  data: number[] = [];
  chartCaption: string = '';
}

@Component({
  selector: 'app-report-chart',
  templateUrl: './report-chart.component.html',
})
export class ReportChartComponent  implements OnInit, AfterViewInit, OnDestroy {

  @Input() reportChartGroup: FormGroup | any;
  protected formBuilder: FormBuilder;
  @Input() reportType: string;
  @Input() formSubmissions: FormSubmissionVO[] | undefined;
  @Input() labelSource: string;
  @Input() labels: any[];
  @Input() selectedDataLabels: any[];
  @Input() dataLabels: string;
  @Input() colors: any;
  @Input() chartIndex: number;
  sections: any[] = []
  periods: any[] = []
  labelNames: string[] = [];

  @ViewChild(BaseChartDirective) chart: BaseChartDirective;

  datasets: ChartDataset[] =[];
  
  constructor(private injector: Injector) {
    this.formBuilder = this.injector.get(FormBuilder);
  }

  ngOnInit(): void {
    
    this.setSections();

    this.reportChartGroup.addControl("period", this.formBuilder.control([]));
    this.reportChartGroup.addControl("section", this.formBuilder.control([]));
    this.chartTypeControl.patchValue('bar');
    this.periodControl.patchValue('all');

    this.setLabels();
    this.datasets = this.barChartDataSets();
    
  }

  ngAfterViewInit(): void {
    
  }

  ngOnDestroy(): void {
  }

  setLabels() {
    this.labelNames = [];
    this.labels?.forEach(label => {
      if(label?.fieldName) {
        this.labelNames?.push(label.fieldName)
      } else {
        this.labelNames?.push(label)
      }
      
    });
  }

  setSections() {
    let sections = {};
    if(this.formSubmissions && this.formSubmissions.length > 0) {
      this.formSubmissions[0].sections.forEach((section: DataFieldSectionVO) => {
        sections[section.sectionId] = section.sectionLabel;
      });

      this.setPeriods();
    }

    Object.keys(sections).forEach(key => {
      this.sections.push({
        sectionId: key,
        sectionLabel: sections[key]
      });
    });
  }

  setPeriods() {
    let periods: string[] = [];
    this.formSubmissions?.forEach(submission => {
      periods.push(submission?.period?.periodName);
    });

    this.periods = [...new Set(periods)]
  }

  newForm(chart: ReportChart): FormGroup {
    
    return this.formBuilder.group({
      chartLabel: [chart?.chartLabel],
      chartType: [chart?.chartType],
      chartCaption: [chart?.chartCaption],
      labels: this.formBuilder.array(chart?.labels),
      data: this.formBuilder.array(chart?.data)
    });
  }

  selectedPeriod() {
    this.datasets = this.barChartDataSets();
  }

  selectedFormSection() {

  }

  get chartTypeControl() {
    return this.reportChartGroup.get('chartType') as FormControl;
  }

  get chartType() {
    return this.chartTypeControl.value;
  }

  get periodControl() {
    return this.reportChartGroup.get('period') as FormControl;
  }

  get period() {
    return this.periodControl.value;
  }

  get sectionControl() {
    return this.reportChartGroup.get('section') as FormControl;
  }

  get section() {
    return this.sectionControl.value;
  }

  selectedChartType() {
    if(this.chartType === 'bar') {
      this.datasets = this.barChartDataSets();
    }
  }

  clearReport() {
    
  }

  refreshChart() {
    this.setPeriods();
    this.setLabels();
    this.datasets = this.barChartDataSets();
  }

  get filteredSubmissions() {
    
    if(this.formSubmissions) {

      if(this.period !== 'all') {
        return this.formSubmissions?.filter(submission => submission?.period?.periodName === this.period);
      } else {
        return this.formSubmissions;
      }
    }

    return [];
  }

  get pieChartDatasets() {
    let datasets: any[] = [];

    if(this.dataLabels === 'licensees') {

      this.filteredSubmissions?.forEach(submission => {
        
        let values: number[] = [];
        
        if(this.labelSource === 'fields') {
          let fields: DataFieldVO[] = [];
          submission?.sections?.forEach((section: DataFieldSectionVO) => {
            fields = [...fields, ...section.dataFields]
          });
  
          this.labels?.forEach(label => {
            let field = fields?.find(f => f.formField.fieldId === label.fieldId);
            if(field) {
              values.push(+field.value);
            }
          });
        } else if(this.labelSource === 'periods') {
          let extraction = {};
          
        }

        datasets.push({
          label: submission?.licensee?.licenseeName,
          data: values
        })
      });

    } else if(this.dataLabels === 'periods') {

    } else if(this.dataLabels === 'fields') {
    }

    return datasets;

    return []
  }

  barChartDataSets(): any[] {

    console.log(this.labels);
    let datasets: any[] = [];

    if(this.dataLabels === 'licensees') {
      console.log('licensees')

      this.filteredSubmissions?.forEach(submission => {
        
        let values: number[] = [];

        if(this.labelSource == 'fields') {
          let fields: DataFieldVO[] = [];
        
          submission?.sections?.forEach((section: DataFieldSectionVO) => {
            fields = [...fields, ...section.dataFields]
          });
          
          this.labels?.forEach(label => {
            let field = fields?.find(f => f.formField.fieldId === label.fieldId);
            if(field) {
              values.push(+field.value);
            }
          });
        } else if(this.labelSource === 'periods') {
          
          let extraction = {};
          if(this.labels.find(label => label === submission?.period?.periodName)) {
            if(!extraction[submission?.period?.periodName]) {
              extraction[submission?.period?.periodName] = []
            }
          }
        }

        let label = submission?.licensee?.licenseeName;

        if(this.period === 'all') {
          label = `${label} - ${submission?.period?.periodName}`;
        }

        datasets.push({
          label: label,
          backgroundColor: this.colors[submission?.licensee?.licenseeName],
          data: values
        })
      });

    } else if(this.dataLabels === 'periods') {

      let extraction = {};

      this.filteredSubmissions?.forEach(submission => {
        console.log(submission);
        submission?.sections?.forEach((section: DataFieldSectionVO) => {
          
        });
      });

    } else if(this.dataLabels === 'fields') {

      let extraction = {};

      this.filteredSubmissions?.forEach(submission => {
        submission?.sections?.forEach((section: DataFieldSectionVO) => {
          section?.dataFields?.forEach((field: DataFieldVO) => {
            
            if(this.selectedDataLabels.find(label => label.fieldId === field?.formField?.fieldId)) {
              let label = field?.formField?.fieldId;
      
              if(this.period === 'all') {
                label = `${label} - ${submission?.period?.periodName}`;
              }
              if(!extraction[label]) {
                extraction[label] = [];
              }
  
              extraction[label].push(field.value);
            }
          })
        });
      });

      
      Object.keys(extraction).forEach(key => {
        datasets.push({
          label: key,
          backgroundColor: this.colors[key],
          data: extraction[key]
        })
      });

      console.log(datasets);
    }

    datasets.sort((a, b) => (a.label > b.label ? 1 : -1))

    return datasets;
  }
}
