// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import {
  AfterViewInit,
  Component,
  EventEmitter,
  Inject,
  Injector,
  Input,
  LOCALE_ID,
  OnDestroy,
  OnInit,
  Output,
  ViewChild,
  ViewChildren,
} from '@angular/core';
import { FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { DataFieldSectionVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-section-vo';
import { DataFieldVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-vo';
import { FormSubmissionVO } from '@app/model/bw/org/bocra/portal/form/submission/form-submission-vo';
import { PeriodVO } from '@app/model/bw/org/bocra/portal/period/period-vo';
import { MatTableExporterDirective } from 'mat-table-exporter';
import * as math from 'mathjs';
import { floor } from 'mathjs';
import { ReportChart, ReportChartComponent } from './report-chart.component';
import { FormEntryType } from '@app/model/bw/org/bocra/portal/form/form-entry-type';

export class ReportElement {
  groupBy: string = '';
  reportType: string = '';
  dataColumns: string = '';
  dataRows: string = '';
  selectAllLicensees: boolean = false;
  selectAllPeriods: boolean = false;
  selectAllForms: boolean = false;
  formSubmissions: FormSubmissionVO[] = [];
  selectedLicensees: any[] = [];
  selectedPeriods: string[] = [];
  selectedFields: string[] = [];
  charts: ReportChart[] = [];
}

export class AdditionalSource {
  rows: string[] = [];
  cols: string[] = [];
}

@Component({
  selector: 'app-report-element',
  templateUrl: './report-element.component.html',
  styleUrls: ['./report-element.component.scss'],
})
export class ReportElementComponent implements OnInit, AfterViewInit, OnDestroy {
  @Input() reportElementGroup: FormGroup | any;
  protected formBuilder: FormBuilder;
  @Input() formSubmissions: FormSubmissionVO[] | undefined;
  @Output() actionIndexEvent = new EventEmitter<number>();
  @ViewChildren('reportChart') reportChartComponents: ReportChartComponent[];
  @ViewChild(MatTableExporterDirective) matTableExporter: MatTableExporterDirective;

  colors = {};
  selectedLicensees: any[] = [];
  selectedFields: any[] = [];
  selectedFieldNames: string[] = [];
  selectedFieldIds: string[] = [];

  selectedPeriods: any[] = [];
  selectedSubmissions: FormSubmissionVO[] | undefined = [];
  additionalDataColumns: any[] = [];
  additionalReportCalculations: any[] = [];
  additionalDataRows: any[] = [];
  customDataColumns: any = {};
  customDataRows: any = {};
  grid: any = {};
  gridData: any = {};
  gridColumnHeaders: any[] = [];
  gridRowHeaders: any[] = [];
  alphabet = [
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
  ];

  gridDataSource = new MatTableDataSource<any>([]);
  @ViewChild('gridPaginator', { static: true }) gridPaginator: MatPaginator;
  @ViewChild('gridSort', { static: true }) gridSort: MatSort;
  gridDataPeriodHeaders: any[] = [];
  gridDataPeriods: any[] = [];
  gridDataColumnHeaders: any[] = [];
  gridDataColumns: any[] = [];
  gridDataColDefs: any[] = [];

  testDataSource: any[] = [];

  periodLengths: any = {};
  periods: any[] = [];
  periodAliases: any = {};
  originalColumnLen: number = 0;
  entryType: FormEntryType = FormEntryType.SINGLE;
  formEntryType = FormEntryType;
  multipleDatasources = {};
  multipleDataColumnNames = {};

  constructor(private injector: Injector, @Inject(LOCALE_ID) public locale: string) {
    this.formBuilder = this.injector.get(FormBuilder);
  }

  ngOnInit(): void {
    this.licensees.forEach((lic, index) => {
      this.licenseeSelectionsArray.insert(index, this.createLicenseeSelectionGroup(true, lic));
    });

    this.getPeriods();

    this.periods.forEach((per, index) => {
      this.periodSelectionsArray.insert(index, this.createPeriodSelectionGroup(true, per?.name));
    });

    if (!this.fieldSelectionsArray) {
      this.reportElementGroup.addControl('fieldSelection', this.formBuilder.array([]));
    }

    this.fields.forEach((field, index) => {
      this.fieldSelectionsArray.insert(index, this.createFieldSelectionGroup(true, field));
    });

    this.reportTypeControl.patchValue('default');
    this.dataColumnsControl.setValue('licensees');

    this.reportElementGroup.addControl('dataColumnsAnalytics', this.formBuilder.array([]));
    this.reportElementGroup.addControl('dataRowsAnalytics', this.formBuilder.array([]));

    this.selectedPeriods = this.periodSelections?.filter((sel) => sel.selected);
    this.selectedFields = this.fieldSelections?.filter((sel) => sel.selected);
    this.selectedFieldIds = this.selectedFields?.map((sel) => sel.fieldId);
    this.selectedFieldNames = this.selectedFields?.map((sel) => sel.alias);
    this.selectedLicensees = this.licenseeSelections?.filter((sel) => sel.selected);

    this.selectedFields?.forEach((field) => {
      this.multipleDataColumnNames[field.fieldId] = field.alias;
    });

    this.generateGridData();
    this.generateMultipleDatasources();

    if (this.formSubmissions) {
      this.entryType = this.formSubmissions[0]?.form?.entryType;
    }

  }

  generateMultipleDatasources() {
    if (!this.formSubmissions || this.formSubmissions.length == 0) {
      return;
    }

    this.selectedSubmissions?.forEach((sub) => {
      if(!this.multipleDatasources[sub.licensee.alias]) {
        this.multipleDatasources[sub.licensee.alias] = [];
      }

      let tmp = {};
      console.log(sub?.dataFields);

      sub?.dataFields?.forEach((field: DataFieldVO) => {
        if(!tmp[field.row]) {
          tmp[field.row] = {};
        }

        tmp[field.row][field?.formField?.fieldId] = field.value;
      });

      this.multipleDatasources[sub.licensee.alias] = Object.values(tmp)
      console.log(this.multipleDatasources);

    });
  }

  generateGridData() {
    if (!this.formSubmissions || this.formSubmissions.length == 0) {
      return;
    }

    this.gridData = {
      length: this.periodSelections.length,
    };

    this.periodSelections?.forEach((per, pindex) => {
      this.selectedSubmissions = this.formSubmissions?.filter((sub) => {
        return (
          per.period === sub?.period?.periodName &&
          this.licenseeSelections?.find((sel) => sel.licensee === sub?.licensee?.licenseeName)
        );
      });

      this.gridData[per.period] = {
        position: pindex,
        alias: per.alias,
        length: this.selectedSubmissions?.length,
      };

      if (this.dataColumns === 'licensees' && this.dataRows === 'fields') {
        this.periodLengths[per.period] = this.selectedSubmissions?.length;
      } else if (this.dataColumns === 'fields' && this.dataRows === 'licensees') {
        this.periodLengths[per.period] = this.fieldSelections?.length;
      }

      this.selectedSubmissions?.forEach((sub, sindex) => {
        let row = sub?.licensee?.licenseeName;
        let rowLabel = sub?.licensee?.licenseeName;
        let rowElementId = `${sub?.id}_${sub?.licensee?.licenseeName.replaceAll(' ', '_')}`;
        let rowIndex = sindex;
        let rowLength = this.selectedSubmissions?.length;

        let col = row;
        let colLabel = rowLabel;
        let colElementId = rowElementId;
        let colIndex = rowIndex;
        let colLength = rowLength;

        let fields: DataFieldVO[] = this.extractFields(sub);

        fields?.forEach((field, findex) => {
          let selF = this.fieldSelections.find((f) => f.fieldId === field.formField.fieldId);

          if (this.dataColumns === 'fields' && this.dataRows === 'licensees') {
            col = field?.formField?.fieldId;
            colLabel = selF?.alias;
            colElementId = `${field?.formField?.fieldId}`;
            colIndex = findex;
            colLength = fields?.length;
          } else if (this.dataColumns === 'licensees' && this.dataRows === 'fields') {
            row = field?.formField?.fieldId;
            rowIndex = findex;
            rowLabel = selF?.alias;
            rowElementId = `${field?.formField?.fieldId}`;
            rowLength = fields?.length;
          }

          this.gridData[per.period]['length'] = rowLength;

          if (!this.gridData[per.period][row]) {
            this.gridData[per.period][row] = {
              label: rowLabel,
              elementId: rowElementId,
              position: rowIndex,
              length: colLength,
            };
          }

          this.gridData[per.period][row][col] = {
            label: colLabel,
            elementId: colElementId,
            position: colIndex,
            value: field?.value,
          };
        });
      });
    });

    this.extractGrid();
  }

  extractGrid() {
    this.gridDataSource.data = [];
    this.grid = {};

    let cindex = 0;

    if (!this.formSubmissions || this.formSubmissions.length == 0) {
      return;
    }

    let columnHeaders = {};
    let periodCols = {};

    Object.keys(this.gridData)?.forEach((pkey) => {
      let periodData = this.gridData[pkey];
      let exclude = ['length', 'alias', 'position', 'label', 'elementId'];

      Object.keys(periodData)?.forEach((rkey) => {
        if (!exclude.includes(rkey)) {
          let row = periodData[rkey];

          if (!this.grid[row?.position]) {
            this.grid[row?.position] = {
              row: row?.position,
              label: row?.label,
              elementId: row?.elementId,
            };
          }

          Object.keys(row)?.forEach((ckey) => {
            if (!exclude.includes(ckey)) {
              let col = row[ckey];

              if (!periodCols[`${periodData?.position} ${col?.position}`]) {
                let alphabet = this.getColumnAlphabet(cindex);
                periodCols[`${periodData?.position} ${col?.position}`] = alphabet;
                columnHeaders[alphabet] = {
                  header: alphabet,
                  colIndex: cindex,
                  period: periodData?.alias,
                  label: col?.label,
                  elementId: col?.elementId,
                };

                cindex++;
              }

              let gridRow: any = Object.values(this.grid)?.find((gr: any) => gr.label === row?.label);

              gridRow[periodCols[`${periodData?.position} ${col?.position}`]] = {
                value: col?.value,
                elementId: col?.elementId,
                label: col?.label,
                period: periodData?.alias,
              };
            }
          });
        }
      });
    });

    this.gridColumnHeaders = Object.values(columnHeaders).sort((a: any, b: any) => a?.colIndex - b?.colIndex);
    this.gridRowHeaders = Object.keys(this.grid).sort((a: any, b: any) => a?.localeCompare(b));
    this.gridDataColumnHeaders = this.gridColumnHeaders?.map((ch) => `${ch.elementId}_${ch.header}`);
    this.gridDataColumns = this.gridColumnHeaders?.map((ch) => {
      return { field: ch.fieldId, header: ch.header, label: ch.label };
    });

    this.gridDataPeriods = this.selectedPeriods?.map((period) => period.period.replaceAll(' ', '_'));
    this.gridDataPeriodHeaders = ['label', ...this.gridDataPeriods];
    this.gridDataColDefs = ['label', ...this.gridDataColumnHeaders];

    this.originalColumnLen = this.gridColumnHeaders.length;

    this.setGridTableData();
  }

  getColumnAlphabet(index: number) {
    let quotient = floor(index / 26) - 1;
    let remainder = index % 26;

    return `${quotient >= 0 ? this.alphabet[quotient] : ''}` + this.alphabet[remainder];
  }

  get licensees() {
    return [...new Set(this.formSubmissions?.map((sub) => sub?.licensee?.licenseeName))];
  }

  periodAliasChange(period: any, k: number) {
    this.periodAliases[period.period] = period.alias;
    let found = this.selectedPeriods.find((pr) => pr.period === period.period);
    found.alias = period.alias;
  }

  getPeriods() {
    let prs: PeriodVO[] | undefined = this.formSubmissions?.map((sub) => sub?.period);
    let prTmp = {};
    prs?.forEach((p) => {
      prTmp[p?.periodName] = p;
    });

    prs = Object.values(prTmp);
    this.periods = prs
      ?.sort((p1, p2) => {
        let start1 = new Date(p1.periodStart);
        let start2 = new Date(p2.periodStart);

        return start1.getTime() - start2.getTime();
      })
      .map((p) => {
        return {
          name: p.periodName,
          length: 0,
        };
      });
  }

  get fields() {
    let formFields: any[] = [];

    if (this.formSubmissions && this.formSubmissions?.length > 0) {
      // if(this.formSubmissions[0]?.form?.entryType === FormEntryType.SINGLE) {

      //   this.formSubmissions[0]?.form?.formSections?.forEach((sec) => {
      //     formFields = [
      //       ...formFields,
      //       ...sec?.formFields?.map((field: any) => {
      //         return { fieldId: field?.fieldId, fieldName: field?.fieldName };
      //       }),
      //     ];
      //   });
      // } else {
      //   console.log('This is a multi entry form')
      this.formSubmissions[0]?.form?.formFields?.forEach((field: any) => {
        formFields.push({ fieldId: field?.fieldId, fieldName: field?.fieldName });
        // formFields = [
        //   ...formFields,
        //   ...sec?.dataFields?.map((field: any) => {
        //     return { fieldId: field?.formField?.fieldId, fieldName: field?.formField?.fieldName };
        //   }),
        // ];
      });
      // }
    }

    return formFields;
  }

  generateColors(reset: boolean) {
    if (reset) {
      this.colors = {};
    }

    if (this.formSubmissions) {
      if (this.dataRows === 'fields') {
        this.formSubmissions[0].sections?.forEach((section: DataFieldSectionVO) => {
          section?.dataFields?.forEach((field: DataFieldVO) => {
            this.colors[field.formField.fieldId] = this.getRandomColor();
          });
        });
      } else if (this.dataRows === 'licensees') {
        this.formSubmissions?.forEach((submission) => {
          if (!this.colors[submission?.licensee?.licenseeName]) {
            this.colors[submission?.licensee?.licenseeName] = this.getRandomColor();
          }
        });
      } else if (this.dataRows === 'periods') {
        this.formSubmissions?.forEach((submission) => {
          this.colors[submission?.period?.periodName] = this.getRandomColor();
        });
      }
    }

    if (this.dataRowsAnalytics?.length > 0) {
      this.dataRowsAnalytics?.forEach((analytic) => {
        this.colors[analytic?.name] = this.getRandomColor();
      });
    }

    this.dataRowsAnalytics?.forEach((row) => {
      if (row?.name) {
        this.colors[row?.name] = this.getRandomColor();
      }
    });
  }

  newForm(reportElement: ReportElement): FormGroup {
    return this.formBuilder.group({
      groupBy: [reportElement?.groupBy],
      reportType: [reportElement?.reportType],
      selectAllLicensees: [reportElement?.selectAllLicensees],
      selectAllPeriods: [reportElement?.selectAllPeriods],
      selectAllForms: [reportElement?.selectAllForms],
      dataColumns: [reportElement?.dataColumns ? reportElement?.dataColumns : 'licensees'],
      dataRows: [reportElement?.dataRows ? reportElement?.dataRows : 'fields'],
      charts: this.createChartsArrayControl([]),
      licenseeSelections: this.createLicenseeSelectionArray(reportElement?.selectedLicensees),
      periodSelections: this.createPeriodSelectionArray(reportElement?.selectedPeriods),
      fieldSelections: this.createFieldSelectionArray(reportElement?.selectedFields),
    });
  }

  getRandomColor() {
    var length = 6;
    var chars = '0123456789ABCDEF';
    var hex = '#';
    while (length--) hex += chars[(Math.random() * 16) | 0];
    return hex;
  }

  refreshColors() {
    Object.keys(this.colors).forEach((key) => {
      this.colors[key] = this.getRandomColor();
    });
  }

  ngAfterViewInit(): void {
    this.generateColors(false);
    this.selectedPeriods = this.periodSelections?.filter((sel) => sel.selected);
    this.selectedFields = this.fieldSelections;
    this.selectedFieldIds = this.selectedFields?.map((sel) => sel.fieldId);
    this.selectedFieldNames = this.selectedFields?.map((sel) => sel.alias);
    this.selectedLicensees = this.licenseeSelections?.filter((sel) => sel.selected);
    this.generateGridData();
  }

  ngOnDestroy(): void {}

  private calculate(values: number[], calculationType: string) {
    if (calculationType === 'sum') {
      return math.sum(values);
    } else if (calculationType === 'mean') {
      return math.mean(values);
    } else if (calculationType === 'mode') {
      return math.mode(values);
    } else if (calculationType === 'median') {
      return math.median(values);
    } else if (calculationType === 'variance') {
      return math.variance(values);
    } else if (calculationType === 'std') {
      return math.std(values);
    } else if (calculationType === 'min') {
      return math.min(values);
    } else if (calculationType === 'max') {
      return math.max(values);
    }
  }

  getExpressionElements(expression: string) {
    let results = [];
    // Stores the indices of
    let dels = [];
    for (let i = 0; i < expression.length; i++) {
      // If opening delimiter
      // is encountered
      if (expression[i] == '[') {
        dels.push(i);
      }

      // If closing delimiter
      // is encountered
      else if (expression[i] == ']' && dels.length > 0) {
        // Extract the position
        // of opening delimiter
        let pos = dels[dels.length - 1];
        dels.pop();

        // Length of substring
        let len = i - 1 - pos;

        results.push(expression.substring(pos + 1, i));
      }
    }
    return [...new Set(results)];
  }

  additionalDataColumnNameChange(event: any, index: number) {
    this.additionalDataColumns = this.dataColumnsAnalytics;
    let changingCol: any = this.additionalDataColumns[index];

    let colIndex = this.originalColumnLen + index;

    if (!changingCol?.type || !changingCol?.name || !changingCol?.sources) {
      return;
    }

    let colAlphabet = this.getColumnAlphabet(colIndex);

    Object.keys(this.grid).forEach((rowKey) => {
      let row = this.grid[rowKey];

      let cell = row[colAlphabet];
      cell.element = changingCol?.name?.replaceAll(' ', '_')?.toLowerCase();
      cell.label = changingCol?.name;
    });

    let found = this.gridColumnHeaders.find((gch) => gch.header === colAlphabet);

    if (found) {
      found.element = `${index}_${changingCol?.name}`;
      found.label = `${changingCol?.name}`;
    }
  }

  customDataColumn(index: number) {
    this.generateColors(false);

    this.additionalDataColumns = this.dataColumnsAnalytics;
    let changingCol: any = this.additionalDataColumns[index];

    if (!changingCol?.type || !changingCol?.name || !changingCol?.sources) {
      return;
    }

    /// Update the periods
    if (this.selectedPeriods.find((lic) => lic.period === changingCol.tag) === undefined) {
      this.selectedPeriods.push({
        selected: true,
        period: changingCol?.tag,
        alias: changingCol?.tag,
      });

      this.periodAliases[changingCol?.tag] = changingCol?.tag;
      this.periodLengths[changingCol?.tag] = 0;
      this.periods.push({ name: changingCol?.tag, length: 0 });
    }

    let source = '';

    let sourceSplit = this.getSources(changingCol?.sources);

    if (changingCol?.type === 'custom') {
      source = sourceSplit.cols[0];
      sourceSplit.cols = Object.keys(this.grid)?.filter((key) => source.includes(`[${key}]`));
    }

    let colIndex = this.originalColumnLen + index;
    let colAlphabet = this.getColumnAlphabet(colIndex);

    let max = Math.max(...Object.values(this.gridData).map((g: any) => (g?.position ? g?.position : 0)));

    if (!this.gridData[changingCol?.tag]) {
      this.gridData[changingCol?.tag] = {
        position: max + 1,
        alias: changingCol?.tag,
        length: 0,
      };

      this.gridData['length']++;
    }

    let gridDataRow = this.gridData[changingCol?.tag];

    sourceSplit?.rows?.forEach((rowKey) => {
      let gridRow = this.grid[rowKey];

      if (!gridDataRow[gridRow?.elementId]) {
        gridDataRow[gridRow?.elementId] = {
          label: gridRow?.label,
          elementId: gridRow?.elementId,
          position: gridRow?.row,
          length: 0,
        };

        gridDataRow.length++;
      }

      if (!gridDataRow[gridRow?.elementId][changingCol?.name]) {
        gridDataRow[gridRow?.elementId][changingCol?.name] = {
          label: changingCol?.name,
          elementId: changingCol?.name?.replaceAll(' ', '_')?.toLowerCase(),
          position: gridDataRow[gridRow?.elementId].length,
          value: changingCol?.type === 'custom' ? source : undefined,
          source: [],
        };

        gridDataRow[gridRow?.elementId].length++;
        this.periodLengths[changingCol?.tag] = gridDataRow[gridRow?.elementId].length;
      }

      let cell: any = gridDataRow[gridRow?.elementId][changingCol?.name];

      sourceSplit.cols?.forEach((colKey) => {
        if (gridRow[colKey] !== undefined) {
          if (changingCol?.type !== 'custom') {
            cell.source.push(gridRow[colKey]);
          }
        }
      });

      if (changingCol?.type === 'custom') {
        Object.keys(gridRow)?.forEach((rk) => {
          if (cell?.value.includes(`[${rk}]`)) {
            cell.value = cell.value.replaceAll(
              `[${rk}]`,
              gridRow[rk].value && gridRow[rk].value !== null ? gridRow[rk].value : 0
            );
          }
        });
      }

      cell.value = Math.round(
        changingCol?.type === 'custom'
          ? math.evaluate(cell.value)
          : this.calculate(
              cell.source?.map((src: any) => (src?.value && src?.value !== null ? src?.value : 0)),
              changingCol?.type
            )
      );

      delete cell.source;
    });

    // Update the selected fields or licensees depending on what the columns are.
    if (this.dataColumns === 'fields') {
      if (this.selectedFields.find((field) => field.fieldName === changingCol.name) === undefined) {
        this.selectedFields.push({
          selected: true,
          fieldName: changingCol.name,
          fieldId: changingCol?.name?.replaceAll(' ', '_'),
          alias: changingCol.name,
        });
        this.selectedFieldIds = this.selectedFields?.map((sel) => sel.fieldId);
        this.selectedFieldNames = this.selectedFields?.map((sel) => sel.alias);
      }
    } else if (this.dataColumns === 'licensees') {
      if (this.selectedLicensees.find((lic) => lic.licensee === changingCol.name) === undefined) {
        this.selectedLicensees.push({ selected: true, licensee: changingCol.name });
      }
    }

    this.extractGrid();
  }

  setGridTableData() {
    this.gridDataSource.data = Object.values(this.grid);
    this.gridDataSource.paginator = this.gridPaginator;
    this.gridDataSource.sort = this.gridSort;
  }

  extractFields(formSubmission: FormSubmissionVO) {
    let fields: DataFieldVO[] = [];

    if (formSubmission?.form?.entryType === FormEntryType.SINGLE) {
      formSubmission?.sections?.forEach((section: DataFieldSectionVO) => {
        fields = [...fields, ...section.dataFields];
      });
    } else {
      formSubmission?.dataFields?.forEach((field: DataFieldVO) => {
        fields.push(field); // = [...fields, ...section.dataFields];
      });
    }

    return fields;
  }

  concatenate(first: string, second: string): string {
    return `${first}: ${second}`;
  }

  getSources(sources: string, type?: string) {
    let additionalSource: AdditionalSource = new AdditionalSource();

    let sourceSplit: string[] = sources
      ?.split('::')
      ?.map((val: any) => val.trim())
      ?.filter((val: any) => val?.length > 0);

    additionalSource.rows = sourceSplit[0]
      ?.split(',')
      ?.map((val: any) => val.trim())
      ?.filter((val: any) => val?.length > 0);

    if (sourceSplit.length == 2) {
      additionalSource.cols = sourceSplit[1]
        ?.split(',')
        ?.map((val: any) => val.trim())
        ?.filter((val: any) => val?.length > 0);

      if (additionalSource.cols.length === 0) {
        additionalSource.cols?.push('all');
      }
    }

    if (additionalSource.rows.length === 1 && additionalSource.rows[0] === 'all') {
      additionalSource.rows = Object.keys(this.grid);
    }

    if (additionalSource.cols.length === 1 && additionalSource.cols[0] === 'all') {
      additionalSource.cols = this.gridColumnHeaders.map((gc) => gc.header);
    }

    return additionalSource;
  }

  additionalRowNameChange(index: number) {
    this.additionalDataRows = this.dataRowsAnalytics;
    let changingRow = this.dataRowsAnalytics[index];

    if (!changingRow?.type || !changingRow?.name || !changingRow?.sources) {
      return;
    }

    let rowIndex: number =
      this.dataColumns === 'fields' ? index + this.licenseeSelections.length : index + this.gridRowHeaders.length;

    let tmp = this.grid[rowIndex];

    tmp.elementId = changingRow?.name?.replaceAll(' ', '_');
    tmp.label = changingRow?.name;

    this.setGridTableData();
  }

  async additionalRowChange(index: number) {
    this.generateColors(false);

    this.additionalDataRows = this.dataRowsAnalytics;
    let changingRow = this.dataRowsAnalytics[index];

    if (!changingRow?.type || !changingRow?.name || !changingRow?.sources) {
      return;
    }

    let source = '';

    let sourceSplit = this.getSources(changingRow?.sources);

    if (changingRow?.type === 'custom') {
      source = sourceSplit.rows[0];
      sourceSplit.rows = Object.keys(this.grid)?.filter((key) => source.includes(`[${key}]`));
    }

    let rowIndex: number = this.gridRowHeaders.length;
    let elementId = `${changingRow?.name?.replaceAll(' ', '_')}`.toLowerCase();

    let rowDefaults: any = {};
    let colPositions: any = {};

    Object.values(this.gridData)?.forEach((periodData: any) => {
      Object.values(periodData)?.forEach((row: any) => {
        if (row?.elementId) {
          if (!rowDefaults[row?.elementId]) {
            rowDefaults[row?.elementId] = {
              elementId: row?.elementId,
              label: row?.label,
              position: row?.position,
            };
          }

          Object.values(row)?.forEach((cell: any) => {
            if (cell?.elementId) {
              colPositions[cell?.elementId] = cell?.position;
            }
          });
        }
      });
    });

    let cellDefaults: any = {};

    sourceSplit?.rows?.forEach((rowKey) => {
      sourceSplit.cols?.forEach((colKey) => {
        let cell = this.grid[rowKey][colKey];

        if (cell && !cellDefaults[colKey]) {
          cellDefaults[colKey] = {
            period: cell.period,
            label: cell.label,
            elementId: cell.elementId,
          };
        }
      });
    });

    sourceSplit?.rows?.forEach(async (rowKey) => {
      let row = this.grid[rowKey];

      await sourceSplit.cols?.forEach(async (colKey) => {
        let cell: any = row[colKey];

        if (!cell) return;

        let cellDefault = cellDefaults[colKey];

        if (!this.gridData[cellDefault.period][elementId]) {
          this.gridData[cellDefault.period][elementId] = {
            elementId: elementId,
            label: changingRow?.name,
            position: rowIndex, /// maybe set to row length
            length: 0,
          };
        }

        this.gridData[cellDefault.period][elementId].position = rowIndex;
        let gridRow: any = this.gridData[cellDefault.period][elementId];

        if (!gridRow[cellDefault.label]) {
          gridRow[cellDefault.label] = {
            label: cellDefault.label,
            position: colPositions[cell.elementId],
            value: undefined,
            source: changingRow?.type === 'custom' ? source : [],
            elementId: cell.elementId,
          };

          gridRow.length++;
        }

        if (gridRow[cellDefault.label]) {
          if (!gridRow[cellDefault.label].source) {
            gridRow[cellDefault.label].source = changingRow?.type === 'custom' ? source : [];
            gridRow[cellDefault.label].position = colPositions[cell.elementId];
          }

          if (row[colKey] !== undefined) {
            if (changingRow?.type === 'custom') {
              if (gridRow[cellDefault.label].source.includes(`[${rowKey}]`)) {
                gridRow[cellDefault.label].source = gridRow[cellDefault.label].source?.replaceAll(
                  `[${rowKey}]`,
                  row[colKey].value
                );
              }
            } else {
              gridRow[cellDefault.label].source.push(row[colKey]);
            }
          }
        }
      });
    });

    sourceSplit.rows?.forEach((rowKey) => {
      let row = this.grid[rowKey];
      sourceSplit.cols?.forEach((colKey) => {
        let cellDefault = cellDefaults[colKey];
        let cell: any = row[colKey];

        if (cell && this.gridData[cellDefault.period][elementId]) {
          let gridRow: any = this.gridData[cellDefault.period][elementId];

          if (gridRow[cellDefault.label]?.source && gridRow[cellDefault.label]?.source?.includes(`[${rowKey}]`)) {
            gridRow[cellDefault.label].source = gridRow[cellDefault.label].source?.replaceAll(`[${rowKey}]`, 0);
          }
        }
      });
    });

    let excludes = ['length', 'alias', 'position'];

    await Object.keys(this.gridData)?.forEach((key) => {
      if (excludes.includes(key)) return;

      let tmpRow = this.gridData[key][elementId];

      if (!tmpRow) return;

      Object.keys(tmpRow)?.forEach(async (key: any) => {
        if (key !== 'label' && key !== 'position' && key != 'length' && key !== 'elementId') {
          let gridCell: any = tmpRow[key];
          let t = gridCell.source;

          gridCell.value = await Math.round(
            changingRow?.type === 'custom'
              ? math.evaluate(gridCell.source)
              : this.calculate(
                  t?.map((src: any) => (src?.value && src?.value !== null ? src?.value : 0)),
                  changingRow?.type
                )
          );

          delete gridCell.source;
        }
      });
    });

    if (this.dataRows === 'fields') {
      if (this.selectedFields.find((lic) => lic.licensee === changingRow.name) === undefined) {
        this.selectedFields.push({
          selected: true,
          fieldName: changingRow.name,
          fieldId: changingRow?.name?.replaceAll(' ', '_'),
          alias: changingRow.name,
        });
      }
    } else if (this.dataRows === 'licensees') {
      if (this.selectedLicensees.find((lic) => lic.licensee === changingRow.name) === undefined) {
        this.selectedLicensees.push({ selected: true, licensee: changingRow.name });
      }
    }

    this.extractGrid();
  }

  createChartsArrayControl(charts: ReportChart[]) {
    let chartControl: FormArray = this.formBuilder.array([]);
    charts.forEach((chart) => {
      chartControl.push(
        this.formBuilder.group({
          chartLabel: [chart?.chartLabel],
          chartType: [chart?.chartType],
          chartCaption: [chart?.chartCaption],
        })
      );
    });
    return chartControl;
  }

  createFieldSelectionArray(fields: any[]) {
    let selections: FormArray = this.formBuilder.array([]);
    this.fields?.forEach((field) => {
      selections?.push(this.createFieldSelectionGroup(fields?.find((f) => f === field) ? true : false, field));
    });
    return selections;
  }

  createFieldSelectionGroup(selected: boolean, field: any): FormGroup {
    return this.formBuilder.group({
      selected: [selected],
      fieldId: [field?.fieldId],
      fieldName: [field?.fieldName],
      alias: [field?.fieldName],
    });
  }

  createLicenseeSelectionArray(licensees: any[]): FormArray {
    let selections: FormArray = this.formBuilder.array([]);
    this.licensees?.forEach((licensee) => {
      selections?.push(
        this.createLicenseeSelectionGroup(licensees?.find((lic) => lic === licensee) ? true : false, licensee)
      );
    });
    return selections;
  }

  createLicenseeSelectionGroup(selected: boolean, licensee: string): FormGroup {
    return this.formBuilder.group({
      selected: [selected],
      licensee: [licensee],
    });
  }

  createPeriodSelectionArray(periods: any[]): FormArray {
    this.getPeriods();
    let selections: FormArray = this.formBuilder.array([]);
    this.periods?.forEach((period) => {
      selections?.push(
        this.createPeriodSelectionGroup(periods?.find((p) => p === period) ? true : false, period?.name)
      );
    });
    return selections;
  }

  createPeriodSelectionGroup(selected: boolean, period: string): FormGroup {
    this.periodAliases[period] = period;
    return this.formBuilder.group({
      selected: [selected],
      period: [period],
      alias: [period],
    });
  }

  periodSelectionChange(event: any, j: number) {
    this.selectionChange(event, j, this.periodSelections, this.periodSelectionsArray, this.selectedPeriods);

    let filtered = this.formSubmissions?.filter((sub) => {
      let f = this.selectedPeriods.find((p) => p.period === sub.period.periodName);
      return f !== undefined;
    });

    this.licenseeSelectionsArray?.controls?.forEach((lc) => {
      if (filtered?.find((sub) => sub.licensee.licenseeName === lc.value.licensee)) {
        lc.get('selected')?.patchValue(true);
      } else {
        lc.get('selected')?.patchValue(false);
      }
    });
  }

  fieldAliasChange(event: any, j: number) {
    let tmp = this.fieldSelectionsArray.at(j).value;

    if (tmp.selected) {
      let index = this.selectedFields?.findIndex((sf) => sf?.fieldId === tmp?.fieldId);
      this.selectedFields[index].alias = tmp.alias;

      this.selectedFieldIds = this.selectedFields?.map((sel) => sel.fieldId);
      this.selectedFieldNames = this.selectedFields?.map((sel) => sel.alias);
    }

    Object.values(this.grid).forEach((value: any) => {
      if (this.dataColumns === 'licensees') {
        if (value.elementId === tmp?.fieldId) {
          value.label = tmp.alias;
        }
      } else {
        Object.values(value).forEach((v: any) => {
          if (v?.elementId === tmp?.fieldId) {
            v.label = tmp.alias;
          }
        });

        this.gridColumnHeaders?.forEach((ch) => {
          if (ch?.elementId === tmp?.fieldId) {
            ch.label = tmp.alias;
          }
        });
      }
    });
  }

  fieldSelectionChange(event: any, j: number) {
    this.selectionChange(event, j, this.fieldSelections, this.fieldSelectionsArray, this.selectedFields);
  }

  licenseeSelectionChange(event: any, j: number) {
    this.selectionChange(event, j, this.licenseeSelections, this.licenseeSelectionsArray, this.selectedLicensees);

    let filtered = this.formSubmissions?.filter((sub) => {
      let f = this.selectedLicensees.find((l) => l.licensee === sub.licensee.licenseeName);
      return f !== undefined;
    });

    this.periodSelectionsArray?.controls?.forEach((pr) => {
      if (filtered?.find((sub: FormSubmissionVO) => sub.period.periodName === pr.value.period)) {
        pr.get('selected')?.patchValue(true);
      } else {
        pr.get('selected')?.patchValue(false);
      }
    });
  }

  private selectionChange(event: any, j: number, selections: any[], selectionsControl: FormArray, selected: any[]) {
    let tmp = selectionsControl.at(j).value;

    if (event.target.checked) {
      let selects = selections?.filter((sel) => sel.selected);
      let select = selects.findIndex((sf) => {
        if (sf?.fieldId) return sf?.fieldId === tmp?.fieldId;
        if (sf?.licensee) return sf?.licensee === tmp?.licensee;
        else return sf?.period === tmp?.period;
      });

      selected.splice(select, 0, tmp);
    } else {
      let index = selected?.findIndex((sf) => {
        if (sf?.fieldId) return sf?.fieldId === tmp?.fieldId;
        if (sf?.licensee) return sf?.licensee === tmp?.licensee;
        else return sf?.period === tmp?.period;
      });

      selected.splice(index, 1);
    }
    return selected;
  }

  selectedChartType() {}

  get allLiceseesSelected() {
    return this.licenseeSelections?.filter((sel) => sel.selected)?.length === this.licensees.length;
  }

  addReportChart() {
    this.chartsControl?.push(
      this.formBuilder.group({
        chartLabel: [],
        chartType: [],
        chartCaption: [],
      })
    );
  }

  get dataColumnsAnalyticsControl(): FormArray {
    return this.reportElementGroup?.get('dataColumnsAnalytics') as FormArray;
  }

  addLabelsAnalytic(target: string) {
    if (target === 'report') {
      this.dataColumnsAnalyticsControl.push(
        this.formBuilder.group({
          type: [],
          sources: [],
          name: [],
          tag: ['Custom'],
        })
      );
    } else {
      this.dataRowsAnalyticsControl.push(
        this.formBuilder.group({
          type: [],
          sources: [],
          name: [],
        })
      );
    }

    this.additionalDataRows = this.dataRowsAnalytics;
  }

  async removeCustomRows(index: number) {
    let i: number = Object.values(this.grid).findIndex(
      (value: any) => value['label'] == this.dataRowsAnalyticsControl.at(index).value.name
    );

    await delete this.grid[`${i}`];

    let tmp = this.dataRowsAnalyticsControl.at(index).value;
    let changingRow = this.dataRowsAnalytics[index];
    let elementId = `${changingRow?.name?.replaceAll(' ', '_')}`.toLowerCase();

    await Object.values(this.gridData)?.forEach((periodData: any) => {
      delete periodData[elementId];
    });

    await this.dataRowsAnalyticsControl.removeAt(index);

    if (this.dataColumns === 'licensees') {
      let i = await this.selectedFields?.findIndex((s) => s.fieldName === tmp.name);

      if (i > -1) {
        await this.selectedFields?.splice(i, 1);
        this.gridRowHeaders = await this.selectedFields?.map((fd: any, i: number) => i);
      }
    } else {
      let i = await this.selectedLicensees?.findIndex((s) => s.fieldName === tmp.name);

      if (i > -1) {
        this.selectedLicensees?.splice(i, 1);
        this.gridRowHeaders = await this.selectedLicensees?.map((fd: any, i: number) => i);
      }
    }

    Object.values(this.gridData).forEach((periodData: any) => {
      if (periodData?.alias) {
        Object.values(periodData)?.forEach((row: any) => {
          if (row?.position && row?.position > i) {
            row.position--;
          }
        });
      }
    });

    // await Object.values(this.grid)?.forEach(async (row: any | undefined) => {

    //   if(row?.position > i) {
    //     await Object.defineProperty(
    //       this.grid,
    //       `${row?.position+1}`,
    //       Object.getOwnPropertyDescriptor(this.grid, `${row?.position}`)
    //     );
    //     delete this.grid[`${row?.position}`];
    //   }
    // })

    // this.setGridTableData();
    await this.extractGrid();
  }

  removeCustomColumns(index: number) {
    this.additionalDataColumns = this.dataColumnsAnalytics;
    let changingCol: any = this.additionalDataColumns[index];
    let periodData = this.gridData[changingCol?.tag];

    Object.values(periodData)?.forEach((row: any) => {
      if (!row[changingCol?.name]) return;

      delete row[changingCol?.name];
      row.length--;

      if (row?.length < 1) {
        periodData.length--;
      }
    });

    if (periodData.length < 1) {
      delete this.gridData[changingCol?.tag];
      delete this.periodAliases[changingCol?.tag];

      let idx: number = this.selectedPeriods?.findIndex((sp) => changingCol?.tag === sp.alias);
      this.selectedPeriods.splice(idx, 1);

      delete this.periodLengths[changingCol?.tag];

      idx = this.periods?.findIndex((sp) => changingCol?.tag === sp.name);
      this.periods.splice(idx, 1);

      this.gridData.length--;
    } else {
      this.periodLengths[changingCol?.tag]--;
    }

    // Update the selected fields or licensees depending on what the columns are.
    if (this.dataColumns === 'fields') {
      let idx: number = this.selectedFields?.findIndex((field) => field.fieldName === changingCol.name);
      if (idx == -1) {
        this.selectedFields.splice(idx, 1);
      }
    } else if (this.dataColumns === 'licensees') {
      let idx: number = this.selectedLicensees?.findIndex((lic) => lic.licensee === changingCol.name);
      if (idx == -1) {
        this.selectedLicensees.splice(idx, 1);
      }
    }

    this.extractGrid();
  }

  removeFromArray(arrayControl: FormArray, index: number) {
    arrayControl.removeAt(index);
  }

  get dataColumnsAnalytics(): any[] {
    return this.dataColumnsAnalyticsControl.value;
  }

  get dataRowsAnalyticsControl(): FormArray {
    return this.reportElementGroup?.get('dataRowsAnalytics') as FormArray;
  }

  get dataRowsAnalytics(): any[] {
    return this.dataRowsAnalyticsControl.value;
  }

  get reportElement(): ReportElement {
    return this.reportElementGroup.value;
  }

  get reportTypeControl() {
    return this.reportElementGroup?.get('reportType') as FormControl;
  }

  get reportType() {
    return this.reportTypeControl?.value;
  }

  get dataColumnsControl() {
    return this.reportElementGroup?.get('dataColumns') as FormControl;
  }

  get dataColumns() {
    return this.dataColumnsControl?.value;
  }

  get dataRowsControl() {
    return this.reportElementGroup?.get('dataRows') as FormControl;
  }

  get dataRows() {
    return this.dataRowsControl?.value;
  }

  get groupByControl() {
    return this.reportElementGroup?.get('groupBy') as FormControl;
  }

  get groupBy() {
    return this.groupByControl?.value;
  }

  get fieldSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('fieldSelections') as FormArray;
  }

  get fieldSelections(): any[] {
    return this.fieldSelectionsArray?.value;
  }

  get licenseeSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('licenseeSelections') as FormArray;
  }

  get licenseeSelections(): any[] {
    return this.licenseeSelectionsArray?.value;
  }

  get periodSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('periodSelections') as FormArray;
  }

  get periodSelections(): any[] {
    return this.periodSelectionsArray?.value;
  }

  get chartsControl(): FormArray {
    return this.reportElementGroup?.get('charts') as FormArray;
  }

  get charts(): ReportChart[] {
    return this.chartsControl.value;
  }

  removeReportChart(chartIndex: number) {
    this.chartsControl.removeAt(chartIndex);
  }

  selectAllChange(event: any, table: string) {
    let arrayControls: FormArray = this.licenseeSelectionsArray;

    if (table === 'periods') {
      arrayControls = this.periodSelectionsArray;
    } else if (table === 'licensees') {
      arrayControls = this.licenseeSelectionsArray;
    }

    if (event?.target?.checked) {
      arrayControls?.controls?.forEach((value) => {
        value.get('selected')?.patchValue(true);
      });
    } else {
      arrayControls?.controls?.forEach((value) => {
        value.get('selected')?.patchValue(false);
      });
    }
  }

  selectDataColumns(event: any) {}

  reportTypeChange() {}

  /**
   * Filter the form submissions based on the selected periods and
   * selected licensees
   */
  get filteredFormSubmissions(): FormSubmissionVO[] {
    let filtered = this.formSubmissions
      ?.filter((submission) => this.selectedPeriods?.find((pr) => pr.period === submission?.period?.periodName))
      ?.filter((submission) =>
        this.selectedLicensees?.find((lc) => lc.licensee === submission?.licensee?.licenseeName)
      );

    return filtered ? filtered : [];
  }

  extractDataColumns(source: string) {
    if (source === 'licensees') {
      return this.licenseeSelections?.filter((lc) => lc.selected).map((lc) => lc.licensee);
    } else if (source === 'periods') {
      return this.periodSelections?.filter((pr) => pr.selected).map((pr) => pr.period);
    } else if (source === 'fields') {
      return this.fieldSelections
        ?.filter((field) => field.selected)
        .map((field) => (field.alias ? field.alias : field.fieldName));
    }

    return [];
  }

  getChartImageData() {
    let charts: any[] = [];
    this.reportChartComponents.forEach((chartComponent) => {
      charts.push(chartComponent.getChartImageData());
    });

    return charts;
  }
}
