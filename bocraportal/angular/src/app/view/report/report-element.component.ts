// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { AfterViewInit, Component, EventEmitter, Injector, Input, OnDestroy, OnInit, Output, QueryList, ViewChildren } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { FormVO } from '@app/model/bw/org/bocra/portal/form/form-vo';
import { DataFieldSectionVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-section-vo';
import { DataFieldVO } from '@app/model/bw/org/bocra/portal/form/submission/data/data-field-vo';
import { FormSubmissionVO } from '@app/model/bw/org/bocra/portal/form/submission/form-submission-vo';
import * as SubmissionActions from '@app/store/form/submission/form-submission.actions';
import * as SubmissionSelectors from '@app/store/form/submission/form-submission.selectors';
import { ReportComponent } from '@app/view/report/report.component';
import { select } from '@ngrx/store';
import { ChartData } from 'chart.js';
import * as math from 'mathjs';
import { BaseChartDirective } from 'ng2-charts';
import { Observable, of } from 'rxjs';
import { ReportChart } from './report-chart.component';

export class ReportElement {
  groupBy: string = '';
  reportType: string = '';
  reportLabels: string = '';
  dataLabels: string = '';
  selectAllLicensees: boolean = false;
  selectAllPeriods: boolean = false;
  selectAllForms: boolean = false;
  formSubmissions: FormSubmissionVO[] = [];
  selectedLicensees: any[] = [];
  selectedPeriods: string[] = [];
  selectedFields: string[] = [];
  charts: ReportChart[] = []
}

@Component({
  selector: 'app-report-element',
  templateUrl: './report-element.component.html',
})
export class ReportElementComponent implements OnInit, AfterViewInit, OnDestroy {

  @Input() reportElementGroup: FormGroup | any;
  protected formBuilder: FormBuilder;
  @Input() formSubmissions: FormSubmissionVO[] | undefined;
  @Output() actionIndexEvent = new EventEmitter<number>()

  colors = {};
  selectedLicensees: any[] = [];
  selectedFields: any[] = [];
  selectedPeriods: any[] = [];
  additionalReportLabels: any[] = [];
  additionalReportCalculations: any[] = [];
  additionalDataLabels: any[] = [];
  customReportLabels: any = {};

  constructor(private injector: Injector) {
    this.formBuilder = this.injector.get(FormBuilder);
  }

  ngOnInit(): void {
    this.licensees.forEach((lic, index) => {
      this.licenseeSelectionsArray.insert(index, this.createLicenseeSelectionGroup(true, lic))
    });

    this.periods.forEach((per, index) => {
      this.periodSelectionsArray.insert(index, this.createPeriodSelectionGroup(true, per))
    });

    if (!this.fieldSelectionsArray) {
      this.reportElementGroup.addControl('fieldSelection', this.formBuilder.array([]));
    }

    this.fields.forEach((field, index) => {
      this.fieldSelectionsArray.insert(index, this.createFieldSelectionGroup(true, field))
    });

    this.reportTypeControl.patchValue('default')
    this.reportLabelsControl.setValue('fields');

    this.reportElementGroup.addControl('reportLabelsAnalytics', this.formBuilder.array([]));
    this.reportElementGroup.addControl('dataLabelsAnalytics', this.formBuilder.array([]));
  }

  get licensees() {
    return [...new Set(this.formSubmissions?.map(sub => sub?.licensee?.licenseeName))];
  }

  get periods() {
    return [...new Set(this.formSubmissions?.map(sub => sub?.period?.periodName))]
  }

  get fields() {

    let formFields: string[] = []

    if (this.formSubmissions && this.formSubmissions?.length > 0) {
      this.formSubmissions[0]?.form?.formSections?.forEach(sec => {
        formFields = [...formFields, ...sec?.formFields?.map((field: any) => {
          return { fieldId: field?.fieldId, fieldName: field?.fieldName }
        })];
      });
    }

    return formFields;
  }

  generateColors(reset: boolean) {
    if (reset) {
      this.colors = {};
    }

    if (this.formSubmissions) {

      if (this.dataLabels === 'fields') {
        this.formSubmissions[0].sections?.forEach((section: DataFieldSectionVO) => {
          section?.dataFields?.forEach((field: DataFieldVO) => {
            this.colors[field.formField.fieldId] = this.getRandomColor()
          })
        });

      } else if (this.dataLabels === 'licensees') {

        this.formSubmissions?.forEach(submission => {
          if (!this.colors[submission?.licensee?.licenseeName]) {
            this.colors[submission?.licensee?.licenseeName] = this.getRandomColor();
          }
        });
      } else if (this.dataLabels === 'periods') {
        this.formSubmissions?.forEach(submission => {
          this.colors[submission?.period?.periodName] = this.getRandomColor();
        });

      }
    }
  }

  newForm(reportElement: ReportElement): FormGroup {

    return this.formBuilder.group({
      groupBy: [reportElement?.groupBy],
      reportType: [reportElement?.reportType],
      selectAllLicensees: [reportElement?.selectAllLicensees],
      selectAllPeriods: [reportElement?.selectAllPeriods],
      selectAllForms: [reportElement?.selectAllForms],
      reportLabels: [reportElement?.reportLabels],
      dataLabels: [reportElement?.dataLabels],
      charts: this.createChartsArrayControl([]),
      licenseeSelections: this.createLicenseeSelectionArray(reportElement?.selectedLicensees),
      periodSelections: this.createPeriodSelectionArray(reportElement?.selectedPeriods),
      fieldSelections: this.createFieldSelectionArray(reportElement?.selectedFields),
    });
  }

  getRandomColor() {
    var length = 6;
    var chars = '0123456789ABCDEF';
    var hex = '#';
    while (length--) hex += chars[(Math.random() * 16) | 0];
    return hex;
  }

  refreshColors() {
    Object.keys(this.colors).forEach(key => {
      this.colors[key] = this.getRandomColor()
    });
  }

  ngAfterViewInit(): void {

    this.dataLabelsControl.patchValue('licensees')
    this.generateColors(false);
    this.periodSelectionChange();
    this.fieldSelectionChange();
    this.licenseeSelectionChange();
  }

  ngOnDestroy(): void {
  }

  private calculate(values: number[], calculationType: string) {
    if (calculationType === 'sum') {
      return math.sum(values)
    } else if (calculationType === 'mean') {
      return math.mean(values)
    } else if (calculationType === 'mode') {
      return math.mode(values)
    } else if (calculationType === 'median') {
      return math.median(values)
    } else if (calculationType === 'variance') {
      return math.variance(values)
    } else if (calculationType === 'std') {
      return math.std(values)
    } else if (calculationType === 'min') {
      return math.min(values)
    } else if (calculationType === 'max') {
      return math.max(values)
    }
  }

  additionalReportLabelChange(index: number) {
    // console.log(this.reportLabelsAnalytics)
    this.additionalReportLabels = this.reportLabelsAnalytics;
    // console.log(this.additionalReportLabels);
    let fields: DataFieldVO[] = [];
    this.filteredFormSubmissions[0]?.sections?.forEach((section: DataFieldSectionVO) => {
      fields = [...fields, ...section?.dataFields];
    });

    let changedlabel: any = this.additionalReportLabels[index];

    if (!changedlabel?.type || !changedlabel?.name || !changedlabel?.sources) {
      return;
    }
    let sourceString: string = changedlabel?.sources;

    if (this.reportLabels === 'fields' && this.dataLabels === 'licensees') {
      this.customReportLabels[index] = {
        name: changedlabel?.name,

      };

      this.filteredFormSubmissions?.forEach(submission => {
        let fields: DataFieldVO[] = [];
        submission?.sections?.forEach((section: DataFieldSectionVO) => {
          fields = [...fields, ...section?.dataFields];
        });

        if (changedlabel?.type === 'custom') {
          let expression = sourceString;
          fields.forEach(field => {
            if (expression?.includes(`[${field.formField.fieldId}]`)) {
              expression = expression?.replace(`[${field.formField.fieldId}]`, field.value);
            }

          });
          // console.log(math.evaluate(expression));

          this.customReportLabels[index][submission?.id] = math.evaluate(expression);
          // console.log(this.customReportLabels);
        } else {
          let sources: string[] = sourceString?.split(',')?.map(val => val.trim())?.filter(val => val?.length > 0);

          let calcFields = fields?.filter((field) => sources?.find(source => field?.formField?.fieldId === source));
          let calValues = calcFields?.map(value => +value?.value);
          if (calValues && calValues.length > 0) {
            let calc = this.calculate(calValues, changedlabel?.type);
            this.customReportLabels[index][submission?.id] = calc;
          }
        }
      });
    } else if (this.reportLabels === 'licensees' && this.dataLabels === 'fields') {

      // console.log(this.periods)
      this.selectedPeriods?.forEach(period => {
        let tmp = this.filteredFormSubmissions?.filter(submission => {

          return submission?.period?.periodName === period;
        })

        // console.log(tmp);
        // this.customReportLabels[`${period} - ${changedlabel?.name}`] = {};
        if (changedlabel?.type === 'custom') {

        } else {
          let sources: string[] = sourceString?.split(',')?.map(val => val.trim())?.filter(val => val?.length > 0);
          let sourceData = {};
          sources?.forEach(source => {

            sourceData[source] = [];

            tmp?.forEach(submission => {
              let fields: DataFieldVO[] = [];
              submission?.sections?.forEach((section: DataFieldSectionVO) => {
                fields = [...fields, ...section?.dataFields];
              });

              let selectedField = fields?.find(field => field.formField?.fieldId === source);
              if(selectedField) {
                sourceData[source].push(+selectedField?.value);
                
              }
            });
          });

          Object.keys(sourceData)?.forEach(key => {
            let selectedField = fields?.find(field => field.formField?.fieldId === key);
            this.customReportLabels[`${period} - ${selectedField?.formField?.fieldName}`] = this.calculate(sourceData[key], changedlabel?.type)
          })
        }
      });
    }  else if (this.reportLabels === 'periods' && this.dataLabels === 'fields') {
    }  else if (this.reportLabels === 'periods' && this.dataLabels === 'licensees') {
      if (changedlabel?.type === 'custom') {

      } else {

        console.log('..........................');
        console.log(this.selectedPeriods);
        let sourceData = {};
        this.filteredFormSubmissions?.forEach(submission => {

          let fields: DataFieldVO[] = [];
          submission?.sections?.forEach((section: DataFieldSectionVO) => {
            fields = [...fields, ...section?.dataFields];
          });

          fields?.forEach(field => {
            if(!sourceData[`${submission?.licensee?.licenseeName} - ${field?.formField?.fieldName}`]) {
              sourceData[`${submission?.licensee?.licenseeName} - ${field?.formField?.fieldName}`] = []
            }

            sourceData[`${submission?.licensee?.licenseeName} - ${field?.formField?.fieldName}`]?.push(+field.value);
          })
        });

        console.log(sourceData);

        Object.keys(sourceData)?.forEach(key => {
          this.customReportLabels[key] = this.calculate(sourceData[key], changedlabel?.type)
        });

        console.log(this.customReportLabels)
      }
    }
  }

  additionalDataLabelChange() {
    this.additionalDataLabels = this.dataLabelsAnalytics;
  }

  createChartsArrayControl(charts: ReportChart[]) {
    let chartControl: FormArray = this.formBuilder.array([]);
    charts.forEach(chart => {
      chartControl.push(this.formBuilder.group({
        chartLabel: [chart?.chartLabel],
        chartType: [chart?.chartType],
        chartCaption: [chart?.chartCaption],
      }))
    })
    return chartControl;
  }

  createFieldSelectionArray(fields: any[]) {

    let selections: FormArray = this.formBuilder.array([]);
    this.fields?.forEach(field => {
      selections?.push(this.createFieldSelectionGroup(fields?.find(f => f === field) ? true : false, field));
    });
    return selections;
  }

  createFieldSelectionGroup(selected: boolean, field: any): FormGroup {
    return this.formBuilder.group({
      selected: [selected],
      fieldId: [field?.fieldId],
      fieldName: [field?.fieldName],
      alias: [field?.fieldName]
    });
  }

  createLicenseeSelectionArray(licensees: any[]): FormArray {

    let selections: FormArray = this.formBuilder.array([]);
    this.licensees?.forEach(licensee => {
      selections?.push(this.createLicenseeSelectionGroup(licensees?.find(lic => lic === licensee) ? true : false, licensee));
    });
    return selections;
  }

  createLicenseeSelectionGroup(selected: boolean, licensee: string): FormGroup {
    return this.formBuilder.group({
      selected: [selected],
      licensee: [licensee]
    });
  }

  createPeriodSelectionArray(periods: any[]): FormArray {

    let selections: FormArray = this.formBuilder.array([]);
    this.periods?.forEach(period => {
      selections?.push(
        this.createPeriodSelectionGroup(periods?.find(p => p === period) ? true : false, period)
      );
    });
    return selections;
  }

  createPeriodSelectionGroup(selected: boolean, period: string): FormGroup {
    return this.formBuilder.group({
      selected: [selected],
      period: [period]
    });
  }

  periodSelectionChange() {
    this.selectedPeriods = this.periodSelections?.filter(sel => sel.selected);
    this.selectedLicensees = this.licenseeSelections?.filter(sel => sel.selected);

    this.licenseeSelectionsArray?.controls?.forEach(lc => {
      if (this.filteredFormSubmissions?.find(sub => sub.licensee.licenseeName === lc.value.licensee)) {
        lc.get('selected')?.patchValue(true);
      } else {
        lc.get('selected')?.patchValue(false);
      }
    });
  }

  fieldSelectionChange() {
    this.selectedFields = this.fieldSelections?.filter(sel => sel.selected);
  }

  licenseeSelectionChange() {
    this.selectedLicensees = this.licenseeSelections?.filter(sel => sel.selected);
    this.selectedPeriods = this.periodSelections?.filter(sel => sel.selected);

    this.periodSelectionsArray?.controls?.forEach(pr => {
      if (this.filteredFormSubmissions?.find((sub: FormSubmissionVO) => sub.period.periodName === pr.value.period)) {
        pr.get('selected')?.patchValue(true);
      } else {
        pr.get('selected')?.patchValue(false);
      }
    });
  }

  selectedChartType() {
    // this.report = this.reportForm.value
    // this.formReports = this.report.formReports;

    // this.chart.forEach((c, index) => {
    //   c.type = this.getReportElement(i, j).chartType
    //   c.update();
    // });
    // return this.getReportElement(i, j).chartType ? this.getReportElement(i, j).chartType : 'bar';
  }

  get allLiceseesSelected() {
    return this.licenseeSelections?.filter(sel => sel.selected)?.length === this.licensees.length
  }

  addReportChart() {
    this.chartsControl?.push(this.formBuilder.group({
      chartLabel: [],
      chartType: [],
      chartCaption: [],
    }));
  }

  get reportLabelsAnalyticsControl(): FormArray {
    return this.reportElementGroup?.get('reportLabelsAnalytics') as FormArray
  }

  addLabelsAnalytic(target: string) {

    if (target === 'report') {
      this.reportLabelsAnalyticsControl.push(
        this.formBuilder.group({
          type: [],
          sources: [],
          name: []
        })
      );
    } else {

      this.dataLabelsAnalyticsControl.push(
        this.formBuilder.group({
          type: [],
          name: []
        })
      );
    }

    this.additionalDataLabelChange();
  }

  removeLabelsAnalytic(target: string, index: number) {

    if (target === 'report') {
      this.reportLabelsAnalyticsControl.removeAt(index)
      this.additionalReportLabelChange(index);
    } else {

      this.dataLabelsAnalyticsControl.removeAt(index)
      this.additionalDataLabelChange();
    }

    this.customReportLabels = {};
    this.additionalReportLabels?.forEach((value, index) => {
      this.additionalReportLabelChange(index);
    })
  }

  removeFromArray(arrayControl: FormArray, index: number) {
    arrayControl.removeAt(index);
  }

  get reportLabelsAnalytics(): any[] {
    return this.reportLabelsAnalyticsControl.value;
  }

  get dataLabelsAnalyticsControl(): FormArray {
    return this.reportElementGroup?.get('dataLabelsAnalytics') as FormArray
  }

  get dataLabelsAnalytics(): any[] {
    return this.dataLabelsAnalyticsControl.value;
  }

  get reportElement(): ReportElement {
    return this.reportElementGroup.value;
  }

  get reportTypeControl() {
    return this.reportElementGroup?.get('reportType') as FormControl;
  }

  get reportType() {
    return this.reportTypeControl?.value
  }

  get reportLabelsControl() {
    return this.reportElementGroup?.get('reportLabels') as FormControl;
  }

  get reportLabels() {
    return this.reportLabelsControl?.value
  }

  get dataLabelsControl() {
    return this.reportElementGroup?.get('dataLabels') as FormControl;
  }

  get dataLabels() {
    return this.dataLabelsControl?.value
  }

  get groupByControl() {
    return this.reportElementGroup?.get('groupBy') as FormControl;
  }

  get groupBy() {
    return this.groupByControl?.value
  }

  get fieldSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('fieldSelections') as FormArray;

  }

  get fieldSelections(): any[] {
    return this.fieldSelectionsArray?.value
  }

  get licenseeSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('licenseeSelections') as FormArray;

  }

  get licenseeSelections(): any[] {
    return this.licenseeSelectionsArray?.value
  }

  get periodSelectionsArray(): FormArray {
    return this.reportElementGroup?.get('periodSelections') as FormArray;

  }

  get periodSelections(): any[] {
    return this.periodSelectionsArray?.value
  }

  get chartsControl(): FormArray {
    return this.reportElementGroup?.get('charts') as FormArray;
  }

  get charts(): ReportChart[] {
    return this.chartsControl.value;
  }

  removeReportChart(chartIndex: number) {
    this.chartsControl.removeAt(chartIndex);
  }

  selectAllChange(event: any, table: string) {

    let arrayControls: FormArray = this.licenseeSelectionsArray;

    if (table === 'periods') {
      arrayControls = this.periodSelectionsArray;
    } else if (table === 'licensees') {
      arrayControls = this.licenseeSelectionsArray;
    }

    if (event?.target?.checked) {
      arrayControls?.controls?.forEach(value => {
        value.get('selected')?.patchValue(true);
      });
    } else {

      arrayControls?.controls?.forEach(value => {
        value.get('selected')?.patchValue(false);
      });
    }
  }

  selectReportLabels(event: any) {
    // if(event?.target?.value === 'licensees') {
    //   this.labels = this.licenseeSelections.filter(lc => lc.selected).map(lc => lc.licensee);
    // } if(event?.target?.value === 'periods') {
    //   this.labels = this.periodSelections.filter(pr => pr.selected).map(pr => pr.period);
    // }
  }

  reportTypeChange() {
    // if(this.reportType) {
    //   this.reportLabelsControl.patchValue('fields');
    //   this.dataLabelsControl.patchValue('licensees')
    // } 
  }

  /**
   * Filter the form submissions based on the selected periods and
   * selected licensees
   */
  get filteredFormSubmissions(): FormSubmissionVO[] {
    let selectedPeriods = this.periodSelections?.filter(pr => pr.selected);
    let selectedLicensees = this.licenseeSelections?.filter(lc => lc.selected);

    let filtered = this.formSubmissions
      ?.filter(submission => selectedPeriods
        ?.find(pr => pr.period === submission?.period?.periodName))
      ?.filter(submission => selectedLicensees
        ?.find(lc => lc.licensee === submission?.licensee?.licenseeName));

    return filtered ? filtered : [];
  }

  extractReportLabels(source: string) {

    if (source === 'licensees') {
      return this.licenseeSelections?.filter(lc => lc.selected).map(lc => lc.licensee);
    } else if (source === 'periods') {
      return this.periodSelections?.filter(pr => pr.selected).map(pr => pr.period);
    } else if (source === 'fields') {
      return this.fieldSelections?.filter(field => field.selected).map(field => field.alias ? field.alias : field.fieldName);
    }

    return [];
  }
}
